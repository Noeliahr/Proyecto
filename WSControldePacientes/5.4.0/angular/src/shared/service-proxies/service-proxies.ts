/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.5.0.0 (NJsonSchema v10.1.15.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class AgendaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CitaDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Agenda/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CitaDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CitaDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CitaDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CitaDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CitaDtoListResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    anularCita(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Agenda/AnularCita?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnularCita(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnularCita(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAnularCita(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param fecha (optional) 
     * @return Success
     */
    getAllPorFecha(fecha: moment.Moment | undefined): Observable<CitaDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Agenda/GetAllPorFecha?";
        if (fecha === null)
            throw new Error("The parameter 'fecha' cannot be null.");
        else if (fecha !== undefined)
            url_ += "fecha=" + encodeURIComponent(fecha ? "" + fecha.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPorFecha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPorFecha(<any>response_);
                } catch (e) {
                    return <Observable<CitaDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CitaDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPorFecha(response: HttpResponseBase): Observable<CitaDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CitaDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CitaDtoListResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllToday(): Observable<CitaDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Agenda/GetAllToday";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllToday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllToday(<any>response_);
                } catch (e) {
                    return <Observable<CitaDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CitaDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllToday(response: HttpResponseBase): Observable<CitaDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CitaDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CitaDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class CitasServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    anularCita(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Citas/AnularCita?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnularCita(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnularCita(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAnularCita(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCitasByPaciente(id: number | undefined): Observable<CitaDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Citas/GetCitasByPaciente?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCitasByPaciente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCitasByPaciente(<any>response_);
                } catch (e) {
                    return <Observable<CitaDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CitaDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCitasByPaciente(response: HttpResponseBase): Observable<CitaDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CitaDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CitaDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    citar(body: CreateCitaDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Citas/Citar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCitar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCitar(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCitar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ControldeTemperaturaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param user (optional) 
     * @return Success
     */
    get(user: number | undefined): Observable<ControlTemperaturaDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ControldeTemperatura/Get?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ControlTemperaturaDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ControlTemperaturaDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ControlTemperaturaDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ControlTemperaturaDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ControlTemperaturaDtoListResultDto>(<any>null);
    }

    /**
     * @param user (optional) 
     * @return Success
     */
    getByToday(user: number | undefined): Observable<ControlTemperaturaDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ControldeTemperatura/GetByToday?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByToday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByToday(<any>response_);
                } catch (e) {
                    return <Observable<ControlTemperaturaDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ControlTemperaturaDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByToday(response: HttpResponseBase): Observable<ControlTemperaturaDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ControlTemperaturaDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ControlTemperaturaDtoListResultDto>(<any>null);
    }

    /**
     * @param user (optional) 
     * @param fecha (optional) 
     * @return Success
     */
    getByFecha(user: number | undefined, fecha: moment.Moment | undefined): Observable<ControlTemperaturaDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ControldeTemperatura/GetByFecha?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        if (fecha === null)
            throw new Error("The parameter 'fecha' cannot be null.");
        else if (fecha !== undefined)
            url_ += "fecha=" + encodeURIComponent(fecha ? "" + fecha.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByFecha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByFecha(<any>response_);
                } catch (e) {
                    return <Observable<ControlTemperaturaDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ControlTemperaturaDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByFecha(response: HttpResponseBase): Observable<ControlTemperaturaDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ControlTemperaturaDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ControlTemperaturaDtoListResultDto>(<any>null);
    }

    /**
     * @param idPaciente (optional) 
     * @param temp (optional) 
     * @return Success
     */
    addNuevaTemperatura(idPaciente: number | undefined, temp: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ControldeTemperatura/AddNuevaTemperatura?";
        if (idPaciente === null)
            throw new Error("The parameter 'idPaciente' cannot be null.");
        else if (idPaciente !== undefined)
            url_ += "idPaciente=" + encodeURIComponent("" + idPaciente) + "&";
        if (temp === null)
            throw new Error("The parameter 'temp' cannot be null.");
        else if (temp !== undefined)
            url_ += "temp=" + encodeURIComponent("" + temp) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNuevaTemperatura(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNuevaTemperatura(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddNuevaTemperatura(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DatosMedicoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMedico(): Observable<MedicoDto> {
        let url_ = this.baseUrl + "/api/services/app/DatosMedico/GetMedico";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedico(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedico(<any>response_);
                } catch (e) {
                    return <Observable<MedicoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedico(response: HttpResponseBase): Observable<MedicoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: EditMedicoDto | undefined): Observable<MedicoDto> {
        let url_ = this.baseUrl + "/api/services/app/DatosMedico/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MedicoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicoDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MedicoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicoDto>(<any>null);
    }
}

@Injectable()
export class DatosPacienteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    datos(): Observable<PacienteCompletoDto> {
        let url_ = this.baseUrl + "/api/services/app/DatosPaciente/Datos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDatos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDatos(<any>response_);
                } catch (e) {
                    return <Observable<PacienteCompletoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteCompletoDto>><any>_observableThrow(response_);
        }));
    }

    protected processDatos(response: HttpResponseBase): Observable<PacienteCompletoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteCompletoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteCompletoDto>(<any>null);
    }

    /**
     * @param user (optional) 
     * @return Success
     */
    getMisResponsables(user: number | undefined): Observable<MisResponsables> {
        let url_ = this.baseUrl + "/api/services/app/DatosPaciente/GetMisResponsables?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMisResponsables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMisResponsables(<any>response_);
                } catch (e) {
                    return <Observable<MisResponsables>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisResponsables>><any>_observableThrow(response_);
        }));
    }

    protected processGetMisResponsables(response: HttpResponseBase): Observable<MisResponsables> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisResponsables.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisResponsables>(<any>null);
    }

    /**
     * @param user (optional) 
     * @param userName (optional) 
     * @return Success
     */
    buscarResponsableByUserName(user: number | undefined, userName: string | undefined): Observable<MisResponsables> {
        let url_ = this.baseUrl + "/api/services/app/DatosPaciente/BuscarResponsableByUserName?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarResponsableByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarResponsableByUserName(<any>response_);
                } catch (e) {
                    return <Observable<MisResponsables>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisResponsables>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarResponsableByUserName(response: HttpResponseBase): Observable<MisResponsables> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisResponsables.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisResponsables>(<any>null);
    }

    /**
     * @param user (optional) 
     * @return Success
     */
    getMisEnfermedades(user: number | undefined): Observable<MisEnfermedades> {
        let url_ = this.baseUrl + "/api/services/app/DatosPaciente/GetMisEnfermedades?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMisEnfermedades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMisEnfermedades(<any>response_);
                } catch (e) {
                    return <Observable<MisEnfermedades>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisEnfermedades>><any>_observableThrow(response_);
        }));
    }

    protected processGetMisEnfermedades(response: HttpResponseBase): Observable<MisEnfermedades> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisEnfermedades.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisEnfermedades>(<any>null);
    }

    /**
     * @param user (optional) 
     * @param nombre (optional) 
     * @return Success
     */
    buscarEnfermedadesByNombre(user: number | undefined, nombre: string | undefined): Observable<MisEnfermedades> {
        let url_ = this.baseUrl + "/api/services/app/DatosPaciente/BuscarEnfermedadesByNombre?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        if (nombre === null)
            throw new Error("The parameter 'nombre' cannot be null.");
        else if (nombre !== undefined)
            url_ += "nombre=" + encodeURIComponent("" + nombre) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarEnfermedadesByNombre(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarEnfermedadesByNombre(<any>response_);
                } catch (e) {
                    return <Observable<MisEnfermedades>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisEnfermedades>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarEnfermedadesByNombre(response: HttpResponseBase): Observable<MisEnfermedades> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisEnfermedades.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisEnfermedades>(<any>null);
    }

    /**
     * @param user (optional) 
     * @return Success
     */
    getMisPrescripciones(user: number | undefined): Observable<MisPrescripciones> {
        let url_ = this.baseUrl + "/api/services/app/DatosPaciente/GetMisPrescripciones?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMisPrescripciones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMisPrescripciones(<any>response_);
                } catch (e) {
                    return <Observable<MisPrescripciones>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisPrescripciones>><any>_observableThrow(response_);
        }));
    }

    protected processGetMisPrescripciones(response: HttpResponseBase): Observable<MisPrescripciones> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisPrescripciones.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisPrescripciones>(<any>null);
    }

    /**
     * @param user (optional) 
     * @return Success
     */
    getMisRecordatorios(user: number | undefined): Observable<MisRecordatorios> {
        let url_ = this.baseUrl + "/api/services/app/DatosPaciente/GetMisRecordatorios?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMisRecordatorios(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMisRecordatorios(<any>response_);
                } catch (e) {
                    return <Observable<MisRecordatorios>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisRecordatorios>><any>_observableThrow(response_);
        }));
    }

    protected processGetMisRecordatorios(response: HttpResponseBase): Observable<MisRecordatorios> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisRecordatorios.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisRecordatorios>(<any>null);
    }

    /**
     * @param user (optional) 
     * @param fecha (optional) 
     * @return Success
     */
    getMisRecordatoriosByFecha(user: number | undefined, fecha: moment.Moment | undefined): Observable<MisRecordatorios> {
        let url_ = this.baseUrl + "/api/services/app/DatosPaciente/GetMisRecordatoriosByFecha?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        if (fecha === null)
            throw new Error("The parameter 'fecha' cannot be null.");
        else if (fecha !== undefined)
            url_ += "fecha=" + encodeURIComponent(fecha ? "" + fecha.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMisRecordatoriosByFecha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMisRecordatoriosByFecha(<any>response_);
                } catch (e) {
                    return <Observable<MisRecordatorios>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisRecordatorios>><any>_observableThrow(response_);
        }));
    }

    protected processGetMisRecordatoriosByFecha(response: HttpResponseBase): Observable<MisRecordatorios> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisRecordatorios.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisRecordatorios>(<any>null);
    }
}

@Injectable()
export class DatosResponsablesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDatos(): Observable<DatosResponsableDto> {
        let url_ = this.baseUrl + "/api/services/app/DatosResponsables/GetDatos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatos(<any>response_);
                } catch (e) {
                    return <Observable<DatosResponsableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatosResponsableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatos(response: HttpResponseBase): Observable<DatosResponsableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatosResponsableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatosResponsableDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: EditResponsableDto | undefined): Observable<ResponsableDto> {
        let url_ = this.baseUrl + "/api/services/app/DatosResponsables/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponsableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponsableDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponsableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsableDto>(<any>null);
    }
}

@Injectable()
export class EnfermedadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    getAll(ids: number[] | undefined): Observable<EnfermedadDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Enfermedad/GetAll?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<EnfermedadDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnfermedadDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EnfermedadDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnfermedadDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnfermedadDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: EnfermedadDto | undefined): Observable<EnfermedadDto> {
        let url_ = this.baseUrl + "/api/services/app/Enfermedad/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<EnfermedadDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnfermedadDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<EnfermedadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnfermedadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnfermedadDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<EnfermedadDto> {
        let url_ = this.baseUrl + "/api/services/app/Enfermedad/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<EnfermedadDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnfermedadDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EnfermedadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnfermedadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnfermedadDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: EnfermedadDto | undefined): Observable<EnfermedadDto> {
        let url_ = this.baseUrl + "/api/services/app/Enfermedad/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<EnfermedadDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnfermedadDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EnfermedadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnfermedadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnfermedadDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Enfermedad/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param nombre (optional) 
     * @return Success
     */
    buscarporNombre(nombre: string | undefined): Observable<EnfermedadDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Enfermedad/BuscarporNombre?";
        if (nombre === null)
            throw new Error("The parameter 'nombre' cannot be null.");
        else if (nombre !== undefined)
            url_ += "nombre=" + encodeURIComponent("" + nombre) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarporNombre(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarporNombre(<any>response_);
                } catch (e) {
                    return <Observable<EnfermedadDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnfermedadDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarporNombre(response: HttpResponseBase): Observable<EnfermedadDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnfermedadDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnfermedadDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class EnfermedadPacienteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    addEnfermedad(id: number | undefined, body: EnfermedadDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnfermedadPaciente/AddEnfermedad?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEnfermedad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEnfermedad(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddEnfermedad(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    eliminarEnfermedad(id: number | undefined, body: EnfermedadDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnfermedadPaciente/EliminarEnfermedad?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarEnfermedad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarEnfermedad(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEliminarEnfermedad(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAll(id: number | undefined): Observable<EnfermedadPacienteDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EnfermedadPaciente/GetAll?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<EnfermedadPacienteDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnfermedadPacienteDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EnfermedadPacienteDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnfermedadPacienteDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnfermedadPacienteDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDatosPaciente(id: number | undefined): Observable<PacienteEnfermedadDto> {
        let url_ = this.baseUrl + "/api/services/app/EnfermedadPaciente/getDatosPaciente?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatosPaciente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatosPaciente(<any>response_);
                } catch (e) {
                    return <Observable<PacienteEnfermedadDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteEnfermedadDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatosPaciente(response: HttpResponseBase): Observable<PacienteEnfermedadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteEnfermedadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteEnfermedadDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param nombre (optional) 
     * @return Success
     */
    buscarByNombre(id: number | undefined, nombre: string | undefined): Observable<EnfermedadPacienteDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EnfermedadPaciente/BuscarByNombre?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (nombre === null)
            throw new Error("The parameter 'nombre' cannot be null.");
        else if (nombre !== undefined)
            url_ += "nombre=" + encodeURIComponent("" + nombre) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarByNombre(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarByNombre(<any>response_);
                } catch (e) {
                    return <Observable<EnfermedadPacienteDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnfermedadPacienteDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarByNombre(response: HttpResponseBase): Observable<EnfermedadPacienteDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnfermedadPacienteDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnfermedadPacienteDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class MedicamentosServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<MedicamentoDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Medicamentos/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MedicamentoDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicamentoDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MedicamentoDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicamentoDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicamentoDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: MedicamentoDto | undefined): Observable<MedicamentoDto> {
        let url_ = this.baseUrl + "/api/services/app/Medicamentos/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<MedicamentoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicamentoDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MedicamentoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicamentoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicamentoDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<MedicamentoDto> {
        let url_ = this.baseUrl + "/api/services/app/Medicamentos/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<MedicamentoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicamentoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MedicamentoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicamentoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicamentoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: MedicamentoDto | undefined): Observable<MedicamentoDto> {
        let url_ = this.baseUrl + "/api/services/app/Medicamentos/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MedicamentoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicamentoDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MedicamentoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicamentoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicamentoDto>(<any>null);
    }
}

@Injectable()
export class MedicosServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllMedicos(): Observable<MedicoDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Medicos/GetAllMedicos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMedicos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMedicos(<any>response_);
                } catch (e) {
                    return <Observable<MedicoDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicoDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMedicos(response: HttpResponseBase): Observable<MedicoDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicoDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicoDtoListResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserNameMedicos(): Observable<UserNameMedicoDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Medicos/GetAllUserNameMedicos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserNameMedicos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserNameMedicos(<any>response_);
                } catch (e) {
                    return <Observable<UserNameMedicoDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserNameMedicoDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserNameMedicos(response: HttpResponseBase): Observable<UserNameMedicoDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserNameMedicoDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserNameMedicoDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<MedicoDto> {
        let url_ = this.baseUrl + "/api/services/app/Medicos/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<MedicoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MedicoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicoDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MedicoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Medicos/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MedicoDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicoDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MedicoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicoDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMedicoDto | undefined): Observable<MedicoDto> {
        let url_ = this.baseUrl + "/api/services/app/Medicos/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<MedicoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicoDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MedicoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: MedicoDto | undefined): Observable<MedicoDto> {
        let url_ = this.baseUrl + "/api/services/app/Medicos/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MedicoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicoDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MedicoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicoDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Medicos/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MensajeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMensajeDto | undefined): Observable<MensajeDto> {
        let url_ = this.baseUrl + "/api/services/app/Mensaje/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<MensajeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MensajeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MensajeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MensajeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MensajeDto>(<any>null);
    }

    /**
     * @return Success
     */
    getMensaje(): Observable<MensajeSimpleListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Mensaje/GetMensaje";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMensaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMensaje(<any>response_);
                } catch (e) {
                    return <Observable<MensajeSimpleListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MensajeSimpleListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMensaje(response: HttpResponseBase): Observable<MensajeSimpleListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MensajeSimpleListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MensajeSimpleListResultDto>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    getChat(userName: string | undefined): Observable<MensajeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Mensaje/GetChat?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChat(<any>response_);
                } catch (e) {
                    return <Observable<MensajeDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MensajeDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetChat(response: HttpResponseBase): Observable<MensajeDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MensajeDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MensajeDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    anularCitaDarMotivo(body: CreateMensajeDto | undefined): Observable<MensajeDto> {
        let url_ = this.baseUrl + "/api/services/app/Mensaje/AnularCitaDarMotivo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnularCitaDarMotivo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnularCitaDarMotivo(<any>response_);
                } catch (e) {
                    return <Observable<MensajeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MensajeDto>><any>_observableThrow(response_);
        }));
    }

    protected processAnularCitaDarMotivo(response: HttpResponseBase): Observable<MensajeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MensajeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MensajeDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<MensajeDto> {
        let url_ = this.baseUrl + "/api/services/app/Mensaje/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<MensajeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MensajeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MensajeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MensajeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MensajeDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MensajeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Mensaje/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MensajeDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MensajeDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MensajeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MensajeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MensajeDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: MensajeDto | undefined): Observable<MensajeDto> {
        let url_ = this.baseUrl + "/api/services/app/Mensaje/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MensajeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MensajeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MensajeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MensajeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MensajeDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Mensaje/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MiCitaMedicaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMisCitas(): Observable<CitaDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MiCitaMedica/GetMisCitas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMisCitas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMisCitas(<any>response_);
                } catch (e) {
                    return <Observable<CitaDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CitaDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMisCitas(response: HttpResponseBase): Observable<CitaDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CitaDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CitaDtoListResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    anularCita(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MiCitaMedica/AnularCita?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnularCita(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnularCita(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAnularCita(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MisResponsablesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<PacienteMiResponsableDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MisResponsables/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PacienteMiResponsableDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteMiResponsableDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PacienteMiResponsableDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteMiResponsableDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteMiResponsableDtoListResultDto>(<any>null);
    }

    /**
     * @param pacienteId (optional) 
     * @param responsableId (optional) 
     * @return Success
     */
    asociarResponsables(pacienteId: number | undefined, responsableId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MisResponsables/AsociarResponsables?";
        if (pacienteId === null)
            throw new Error("The parameter 'pacienteId' cannot be null.");
        else if (pacienteId !== undefined)
            url_ += "pacienteId=" + encodeURIComponent("" + pacienteId) + "&";
        if (responsableId === null)
            throw new Error("The parameter 'responsableId' cannot be null.");
        else if (responsableId !== undefined)
            url_ += "responsableId=" + encodeURIComponent("" + responsableId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsociarResponsables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsociarResponsables(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAsociarResponsables(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PacienteEnfermedadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<EnfermedadPacienteDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteEnfermedad/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<EnfermedadPacienteDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnfermedadPacienteDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EnfermedadPacienteDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnfermedadPacienteDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnfermedadPacienteDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class PacienteMedicoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRole(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/GetRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRole(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetRole(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPacientes(): Observable<PacienteDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/GetAllPacientes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPacientes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPacientes(<any>response_);
                } catch (e) {
                    return <Observable<PacienteDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPacientes(response: HttpResponseBase): Observable<PacienteDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteDtoListResultDto>(<any>null);
    }

    /**
     * @param numSS (optional) 
     * @return Success
     */
    buscarPorNumSS(numSS: number | undefined): Observable<PacienteDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/BuscarPorNumSS?";
        if (numSS === null)
            throw new Error("The parameter 'numSS' cannot be null.");
        else if (numSS !== undefined)
            url_ += "numSS=" + encodeURIComponent("" + numSS) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarPorNumSS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarPorNumSS(<any>response_);
                } catch (e) {
                    return <Observable<PacienteDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarPorNumSS(response: HttpResponseBase): Observable<PacienteDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteDtoListResultDto>(<any>null);
    }

    /**
     * @param nombre (optional) 
     * @return Success
     */
    buscarPorNombre(nombre: string | undefined): Observable<PacienteDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/BuscarPorNombre?";
        if (nombre === null)
            throw new Error("The parameter 'nombre' cannot be null.");
        else if (nombre !== undefined)
            url_ += "nombre=" + encodeURIComponent("" + nombre) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarPorNombre(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarPorNombre(<any>response_);
                } catch (e) {
                    return <Observable<PacienteDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarPorNombre(response: HttpResponseBase): Observable<PacienteDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteDtoListResultDto>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    buscarPorLogin(userName: string | undefined): Observable<PacienteDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/BuscarPorLogin?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarPorLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarPorLogin(<any>response_);
                } catch (e) {
                    return <Observable<PacienteDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarPorLogin(response: HttpResponseBase): Observable<PacienteDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMisResponsables(id: number | undefined): Observable<MisResponsables> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/GetMisResponsables?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMisResponsables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMisResponsables(<any>response_);
                } catch (e) {
                    return <Observable<MisResponsables>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisResponsables>><any>_observableThrow(response_);
        }));
    }

    protected processGetMisResponsables(response: HttpResponseBase): Observable<MisResponsables> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisResponsables.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisResponsables>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    desasociarResponsable(id: number | undefined, body: ResponsableDto | undefined): Observable<MisResponsables> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/DesasociarResponsable?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDesasociarResponsable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDesasociarResponsable(<any>response_);
                } catch (e) {
                    return <Observable<MisResponsables>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisResponsables>><any>_observableThrow(response_);
        }));
    }

    protected processDesasociarResponsable(response: HttpResponseBase): Observable<MisResponsables> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisResponsables.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisResponsables>(<any>null);
    }

    /**
     * @param user (optional) 
     * @param userName (optional) 
     * @return Success
     */
    buscarResponsableByUserName(user: number | undefined, userName: string | undefined): Observable<MisResponsables> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/BuscarResponsableByUserName?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarResponsableByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarResponsableByUserName(<any>response_);
                } catch (e) {
                    return <Observable<MisResponsables>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisResponsables>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarResponsableByUserName(response: HttpResponseBase): Observable<MisResponsables> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisResponsables.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisResponsables>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMisEnfermedades(id: number | undefined): Observable<MisEnfermedadesListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/GetMisEnfermedades?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMisEnfermedades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMisEnfermedades(<any>response_);
                } catch (e) {
                    return <Observable<MisEnfermedadesListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisEnfermedadesListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMisEnfermedades(response: HttpResponseBase): Observable<MisEnfermedadesListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisEnfermedadesListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisEnfermedadesListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEvoluciondeTemperatura(id: number | undefined): Observable<MiEvolucionTemperatura> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/GetEvoluciondeTemperatura?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEvoluciondeTemperatura(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvoluciondeTemperatura(<any>response_);
                } catch (e) {
                    return <Observable<MiEvolucionTemperatura>><any>_observableThrow(e);
                }
            } else
                return <Observable<MiEvolucionTemperatura>><any>_observableThrow(response_);
        }));
    }

    protected processGetEvoluciondeTemperatura(response: HttpResponseBase): Observable<MiEvolucionTemperatura> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MiEvolucionTemperatura.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MiEvolucionTemperatura>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param fecha (optional) 
     * @return Success
     */
    getEvoluciondeTemperaturaByFecha(id: number | undefined, fecha: moment.Moment | undefined): Observable<MiEvolucionTemperatura> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/GetEvoluciondeTemperaturaByFecha?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (fecha === null)
            throw new Error("The parameter 'fecha' cannot be null.");
        else if (fecha !== undefined)
            url_ += "fecha=" + encodeURIComponent(fecha ? "" + fecha.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEvoluciondeTemperaturaByFecha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvoluciondeTemperaturaByFecha(<any>response_);
                } catch (e) {
                    return <Observable<MiEvolucionTemperatura>><any>_observableThrow(e);
                }
            } else
                return <Observable<MiEvolucionTemperatura>><any>_observableThrow(response_);
        }));
    }

    protected processGetEvoluciondeTemperaturaByFecha(response: HttpResponseBase): Observable<MiEvolucionTemperatura> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MiEvolucionTemperatura.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MiEvolucionTemperatura>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDatosCompletosByPaciente(id: number | undefined): Observable<PacienteCompletoDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedico/GetDatosCompletosByPaciente?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatosCompletosByPaciente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatosCompletosByPaciente(<any>response_);
                } catch (e) {
                    return <Observable<PacienteCompletoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteCompletoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatosCompletosByPaciente(response: HttpResponseBase): Observable<PacienteCompletoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteCompletoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteCompletoDto>(<any>null);
    }
}

@Injectable()
export class PacienteMedicoCabeceraServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePacienteDto | undefined): Observable<PacienteDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedicoCabecera/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PacienteDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PacienteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: EditPacienteDto | undefined): Observable<PacienteDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedicoCabecera/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PacienteDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PacienteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedicoCabecera/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMedicosCabecera(): Observable<UserNameMedicosCabeceraListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedicoCabecera/GetAllMedicosCabecera";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMedicosCabecera(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMedicosCabecera(<any>response_);
                } catch (e) {
                    return <Observable<UserNameMedicosCabeceraListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserNameMedicosCabeceraListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMedicosCabecera(response: HttpResponseBase): Observable<UserNameMedicosCabeceraListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserNameMedicosCabeceraListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserNameMedicosCabeceraListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDatosCompletosByPaciente(id: number | undefined): Observable<PacienteCompletoDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteMedicoCabecera/GetDatosCompletosByPaciente?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatosCompletosByPaciente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatosCompletosByPaciente(<any>response_);
                } catch (e) {
                    return <Observable<PacienteCompletoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteCompletoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatosCompletosByPaciente(response: HttpResponseBase): Observable<PacienteCompletoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteCompletoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteCompletoDto>(<any>null);
    }
}

@Injectable()
export class PacienteResponsableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPacientes(): Observable<PacienteDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteResponsable/GetAllPacientes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPacientes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPacientes(<any>response_);
                } catch (e) {
                    return <Observable<PacienteDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPacientes(response: HttpResponseBase): Observable<PacienteDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteDtoListResultDto>(<any>null);
    }

    /**
     * @param numSS (optional) 
     * @return Success
     */
    buscarPorNumSS(numSS: number | undefined): Observable<PacienteDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteResponsable/BuscarPorNumSS?";
        if (numSS === null)
            throw new Error("The parameter 'numSS' cannot be null.");
        else if (numSS !== undefined)
            url_ += "numSS=" + encodeURIComponent("" + numSS) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarPorNumSS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarPorNumSS(<any>response_);
                } catch (e) {
                    return <Observable<PacienteDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarPorNumSS(response: HttpResponseBase): Observable<PacienteDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteDtoListResultDto>(<any>null);
    }

    /**
     * @param nombre (optional) 
     * @return Success
     */
    buscarPorNombre(nombre: string | undefined): Observable<PacienteDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteResponsable/BuscarPorNombre?";
        if (nombre === null)
            throw new Error("The parameter 'nombre' cannot be null.");
        else if (nombre !== undefined)
            url_ += "nombre=" + encodeURIComponent("" + nombre) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarPorNombre(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarPorNombre(<any>response_);
                } catch (e) {
                    return <Observable<PacienteDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarPorNombre(response: HttpResponseBase): Observable<PacienteDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteDtoListResultDto>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    buscarPorLogin(userName: string | undefined): Observable<PacienteDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteResponsable/BuscarPorLogin?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarPorLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarPorLogin(<any>response_);
                } catch (e) {
                    return <Observable<PacienteDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarPorLogin(response: HttpResponseBase): Observable<PacienteDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMisResponsables(id: number | undefined): Observable<MisResponsables> {
        let url_ = this.baseUrl + "/api/services/app/PacienteResponsable/GetMisResponsables?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMisResponsables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMisResponsables(<any>response_);
                } catch (e) {
                    return <Observable<MisResponsables>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisResponsables>><any>_observableThrow(response_);
        }));
    }

    protected processGetMisResponsables(response: HttpResponseBase): Observable<MisResponsables> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisResponsables.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisResponsables>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMisEnfermedades(id: number | undefined): Observable<MisEnfermedades> {
        let url_ = this.baseUrl + "/api/services/app/PacienteResponsable/GetMisEnfermedades?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMisEnfermedades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMisEnfermedades(<any>response_);
                } catch (e) {
                    return <Observable<MisEnfermedades>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisEnfermedades>><any>_observableThrow(response_);
        }));
    }

    protected processGetMisEnfermedades(response: HttpResponseBase): Observable<MisEnfermedades> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisEnfermedades.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisEnfermedades>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEvoluciondeTemperatura(id: number | undefined): Observable<MiEvolucionTemperatura> {
        let url_ = this.baseUrl + "/api/services/app/PacienteResponsable/GetEvoluciondeTemperatura?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEvoluciondeTemperatura(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvoluciondeTemperatura(<any>response_);
                } catch (e) {
                    return <Observable<MiEvolucionTemperatura>><any>_observableThrow(e);
                }
            } else
                return <Observable<MiEvolucionTemperatura>><any>_observableThrow(response_);
        }));
    }

    protected processGetEvoluciondeTemperatura(response: HttpResponseBase): Observable<MiEvolucionTemperatura> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MiEvolucionTemperatura.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MiEvolucionTemperatura>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param fecha (optional) 
     * @return Success
     */
    getEvoluciondeTemperaturaByFecha(id: number | undefined, fecha: moment.Moment | undefined): Observable<MiEvolucionTemperatura> {
        let url_ = this.baseUrl + "/api/services/app/PacienteResponsable/GetEvoluciondeTemperaturaByFecha?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (fecha === null)
            throw new Error("The parameter 'fecha' cannot be null.");
        else if (fecha !== undefined)
            url_ += "fecha=" + encodeURIComponent(fecha ? "" + fecha.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEvoluciondeTemperaturaByFecha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvoluciondeTemperaturaByFecha(<any>response_);
                } catch (e) {
                    return <Observable<MiEvolucionTemperatura>><any>_observableThrow(e);
                }
            } else
                return <Observable<MiEvolucionTemperatura>><any>_observableThrow(response_);
        }));
    }

    protected processGetEvoluciondeTemperaturaByFecha(response: HttpResponseBase): Observable<MiEvolucionTemperatura> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MiEvolucionTemperatura.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MiEvolucionTemperatura>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDatosCompletosByPaciente(id: number | undefined): Observable<PacienteCompletoDto> {
        let url_ = this.baseUrl + "/api/services/app/PacienteResponsable/GetDatosCompletosByPaciente?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatosCompletosByPaciente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatosCompletosByPaciente(<any>response_);
                } catch (e) {
                    return <Observable<PacienteCompletoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PacienteCompletoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatosCompletosByPaciente(response: HttpResponseBase): Observable<PacienteCompletoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PacienteCompletoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PacienteCompletoDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPrescripciones(id: number | undefined): Observable<MisPrescripciones> {
        let url_ = this.baseUrl + "/api/services/app/PacienteResponsable/GetPrescripciones?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrescripciones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrescripciones(<any>response_);
                } catch (e) {
                    return <Observable<MisPrescripciones>><any>_observableThrow(e);
                }
            } else
                return <Observable<MisPrescripciones>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrescripciones(response: HttpResponseBase): Observable<MisPrescripciones> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MisPrescripciones.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MisPrescripciones>(<any>null);
    }
}

@Injectable()
export class PrescripcionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAll(id: number | undefined): Observable<PrescripcionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Prescripcion/GetAll?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PrescripcionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrescripcionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PrescripcionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PrescripcionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrescripcionDto[]>(<any>null);
    }

    /**
     * @param idPaciente (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(idPaciente: number | undefined, body: CreatePrescripcionDto | undefined): Observable<PrescripcionDto> {
        let url_ = this.baseUrl + "/api/services/app/Prescripcion/Create?";
        if (idPaciente === null)
            throw new Error("The parameter 'idPaciente' cannot be null.");
        else if (idPaciente !== undefined)
            url_ += "idPaciente=" + encodeURIComponent("" + idPaciente) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PrescripcionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrescripcionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PrescripcionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescripcionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrescripcionDto>(<any>null);
    }

    /**
     * @param idPaciente (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(idPaciente: number | undefined, body: PrescripcionDto | undefined): Observable<PrescripcionDto> {
        let url_ = this.baseUrl + "/api/services/app/Prescripcion/Update?";
        if (idPaciente === null)
            throw new Error("The parameter 'idPaciente' cannot be null.");
        else if (idPaciente !== undefined)
            url_ += "idPaciente=" + encodeURIComponent("" + idPaciente) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PrescripcionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrescripcionDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PrescripcionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescripcionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrescripcionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPrescripcion(id: number | undefined): Observable<PrescripcionDto> {
        let url_ = this.baseUrl + "/api/services/app/Prescripcion/GetPrescripcion?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrescripcion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrescripcion(<any>response_);
                } catch (e) {
                    return <Observable<PrescripcionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrescripcionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrescripcion(response: HttpResponseBase): Observable<PrescripcionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrescripcionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrescripcionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Prescripcion/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RecordatorioServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAll(id: number | undefined): Observable<RecordatorioDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Recordatorio/GetAll?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RecordatorioDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecordatorioDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RecordatorioDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecordatorioDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecordatorioDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRecordatoriosToday(id: number | undefined): Observable<RecordatorioDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Recordatorio/GetRecordatoriosToday?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecordatoriosToday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecordatoriosToday(<any>response_);
                } catch (e) {
                    return <Observable<RecordatorioDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecordatorioDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecordatoriosToday(response: HttpResponseBase): Observable<RecordatorioDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecordatorioDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecordatorioDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createByPrescripcion(body: PrescripcionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Recordatorio/CreateByPrescripcion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateByPrescripcion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateByPrescripcion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateByPrescripcion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param idPaciente (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(idPaciente: number | undefined, body: RecordatorioDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Recordatorio/Create?";
        if (idPaciente === null)
            throw new Error("The parameter 'idPaciente' cannot be null.");
        else if (idPaciente !== undefined)
            url_ += "idPaciente=" + encodeURIComponent("" + idPaciente) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Recordatorio/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RecordatorioDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Recordatorio/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RecordatorioDto> {
        let url_ = this.baseUrl + "/api/services/app/Recordatorio/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RecordatorioDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecordatorioDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RecordatorioDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecordatorioDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecordatorioDto>(<any>null);
    }
}

@Injectable()
export class ResponsableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateResponsableDto | undefined): Observable<ResponsableDto> {
        let url_ = this.baseUrl + "/api/services/app/Responsable/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponsableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponsableDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponsableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsableDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    getAll(ids: number[] | undefined): Observable<ResponsableDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Responsable/GetAll?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ResponsableDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponsableDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ResponsableDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsableDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsableDtoListResultDto>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    buscarByUserNameOrName(name: string | undefined): Observable<ResponsableDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Responsable/BuscarByUserNameOrName?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscarByUserNameOrName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscarByUserNameOrName(<any>response_);
                } catch (e) {
                    return <Observable<ResponsableDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponsableDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processBuscarByUserNameOrName(response: HttpResponseBase): Observable<ResponsableDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsableDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsableDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string | undefined;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string | undefined;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class CitaDto implements ICitaDto {
    pacienteDatosPersonalesUserName: string | undefined;
    pacienteDatosPersonalesName: string | undefined;
    pacienteDatosPersonalesSurname: string | undefined;
    medicoDatosPersonalesUserName: string | undefined;
    medicoDatosPersonalesName: string | undefined;
    medicoDatosPersonalesSurname: string | undefined;
    medicoDatosPersonalesEmailAddress: string | undefined;
    medicoDatosPersonalesTelefono: string | undefined;
    fechaHora: moment.Moment;
    consulta: string | undefined;
    servicio_Especialidad: string | undefined;
    centro: string | undefined;
    direccionTipo: string | undefined;
    direccionNombre: string | undefined;
    direccionNumero: number;
    direccionLetra: string | undefined;
    direccionKmenlavia: number;
    direccionBloque: string | undefined;
    direccionPortal: string | undefined;
    direccionEscalera: string | undefined;
    direccionPlanta: number;
    direccionPuerta: string;
    direccionCodigoPostal: string | undefined;
    direccionEntidaddePoblacion: string | undefined;
    direccionMunicipio: string | undefined;
    direccionProvincia: string | undefined;
    direccionPais: string | undefined;
    id: number;

    constructor(data?: ICitaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pacienteDatosPersonalesUserName = _data["pacienteDatosPersonalesUserName"];
            this.pacienteDatosPersonalesName = _data["pacienteDatosPersonalesName"];
            this.pacienteDatosPersonalesSurname = _data["pacienteDatosPersonalesSurname"];
            this.medicoDatosPersonalesUserName = _data["medicoDatosPersonalesUserName"];
            this.medicoDatosPersonalesName = _data["medicoDatosPersonalesName"];
            this.medicoDatosPersonalesSurname = _data["medicoDatosPersonalesSurname"];
            this.medicoDatosPersonalesEmailAddress = _data["medicoDatosPersonalesEmailAddress"];
            this.medicoDatosPersonalesTelefono = _data["medicoDatosPersonalesTelefono"];
            this.fechaHora = _data["fechaHora"] ? moment(_data["fechaHora"].toString()) : <any>undefined;
            this.consulta = _data["consulta"];
            this.servicio_Especialidad = _data["servicio_Especialidad"];
            this.centro = _data["centro"];
            this.direccionTipo = _data["direccionTipo"];
            this.direccionNombre = _data["direccionNombre"];
            this.direccionNumero = _data["direccionNumero"];
            this.direccionLetra = _data["direccionLetra"];
            this.direccionKmenlavia = _data["direccionKmenlavia"];
            this.direccionBloque = _data["direccionBloque"];
            this.direccionPortal = _data["direccionPortal"];
            this.direccionEscalera = _data["direccionEscalera"];
            this.direccionPlanta = _data["direccionPlanta"];
            this.direccionPuerta = _data["direccionPuerta"];
            this.direccionCodigoPostal = _data["direccionCodigoPostal"];
            this.direccionEntidaddePoblacion = _data["direccionEntidaddePoblacion"];
            this.direccionMunicipio = _data["direccionMunicipio"];
            this.direccionProvincia = _data["direccionProvincia"];
            this.direccionPais = _data["direccionPais"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CitaDto {
        data = typeof data === 'object' ? data : {};
        let result = new CitaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pacienteDatosPersonalesUserName"] = this.pacienteDatosPersonalesUserName;
        data["pacienteDatosPersonalesName"] = this.pacienteDatosPersonalesName;
        data["pacienteDatosPersonalesSurname"] = this.pacienteDatosPersonalesSurname;
        data["medicoDatosPersonalesUserName"] = this.medicoDatosPersonalesUserName;
        data["medicoDatosPersonalesName"] = this.medicoDatosPersonalesName;
        data["medicoDatosPersonalesSurname"] = this.medicoDatosPersonalesSurname;
        data["medicoDatosPersonalesEmailAddress"] = this.medicoDatosPersonalesEmailAddress;
        data["medicoDatosPersonalesTelefono"] = this.medicoDatosPersonalesTelefono;
        data["fechaHora"] = this.fechaHora ? this.fechaHora.toISOString() : <any>undefined;
        data["consulta"] = this.consulta;
        data["servicio_Especialidad"] = this.servicio_Especialidad;
        data["centro"] = this.centro;
        data["direccionTipo"] = this.direccionTipo;
        data["direccionNombre"] = this.direccionNombre;
        data["direccionNumero"] = this.direccionNumero;
        data["direccionLetra"] = this.direccionLetra;
        data["direccionKmenlavia"] = this.direccionKmenlavia;
        data["direccionBloque"] = this.direccionBloque;
        data["direccionPortal"] = this.direccionPortal;
        data["direccionEscalera"] = this.direccionEscalera;
        data["direccionPlanta"] = this.direccionPlanta;
        data["direccionPuerta"] = this.direccionPuerta;
        data["direccionCodigoPostal"] = this.direccionCodigoPostal;
        data["direccionEntidaddePoblacion"] = this.direccionEntidaddePoblacion;
        data["direccionMunicipio"] = this.direccionMunicipio;
        data["direccionProvincia"] = this.direccionProvincia;
        data["direccionPais"] = this.direccionPais;
        data["id"] = this.id;
        return data; 
    }

    clone(): CitaDto {
        const json = this.toJSON();
        let result = new CitaDto();
        result.init(json);
        return result;
    }
}

export interface ICitaDto {
    pacienteDatosPersonalesUserName: string | undefined;
    pacienteDatosPersonalesName: string | undefined;
    pacienteDatosPersonalesSurname: string | undefined;
    medicoDatosPersonalesUserName: string | undefined;
    medicoDatosPersonalesName: string | undefined;
    medicoDatosPersonalesSurname: string | undefined;
    medicoDatosPersonalesEmailAddress: string | undefined;
    medicoDatosPersonalesTelefono: string | undefined;
    fechaHora: moment.Moment;
    consulta: string | undefined;
    servicio_Especialidad: string | undefined;
    centro: string | undefined;
    direccionTipo: string | undefined;
    direccionNombre: string | undefined;
    direccionNumero: number;
    direccionLetra: string | undefined;
    direccionKmenlavia: number;
    direccionBloque: string | undefined;
    direccionPortal: string | undefined;
    direccionEscalera: string | undefined;
    direccionPlanta: number;
    direccionPuerta: string;
    direccionCodigoPostal: string | undefined;
    direccionEntidaddePoblacion: string | undefined;
    direccionMunicipio: string | undefined;
    direccionProvincia: string | undefined;
    direccionPais: string | undefined;
    id: number;
}

export class CitaDtoListResultDto implements ICitaDtoListResultDto {
    items: CitaDto[] | undefined;

    constructor(data?: ICitaDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CitaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CitaDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CitaDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CitaDtoListResultDto {
        const json = this.toJSON();
        let result = new CitaDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface ICitaDtoListResultDto {
    items: CitaDto[] | undefined;
}

export class CreateCitaDto implements ICreateCitaDto {
    pacienteId: number;
    fechaHora: moment.Moment;
    consulta: string | undefined;
    servicio_Especialidad: string | undefined;
    centro: string | undefined;
    direccionTipo: string | undefined;
    direccionNombre: string | undefined;
    direccionNumero: number;
    direccionLetra: string | undefined;
    direccionKmenlavia: number;
    direccionBloque: string | undefined;
    direccionPortal: string | undefined;
    direccionEscalera: string | undefined;
    direccionPlanta: number;
    direccionPuerta: string;
    direccionCodigoPostal: string | undefined;
    direccionEntidaddePoblacion: string | undefined;
    direccionMunicipio: string | undefined;
    direccionProvincia: string | undefined;
    direccionPais: string | undefined;
    id: number;

    constructor(data?: ICreateCitaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pacienteId = _data["pacienteId"];
            this.fechaHora = _data["fechaHora"] ? moment(_data["fechaHora"].toString()) : <any>undefined;
            this.consulta = _data["consulta"];
            this.servicio_Especialidad = _data["servicio_Especialidad"];
            this.centro = _data["centro"];
            this.direccionTipo = _data["direccionTipo"];
            this.direccionNombre = _data["direccionNombre"];
            this.direccionNumero = _data["direccionNumero"];
            this.direccionLetra = _data["direccionLetra"];
            this.direccionKmenlavia = _data["direccionKmenlavia"];
            this.direccionBloque = _data["direccionBloque"];
            this.direccionPortal = _data["direccionPortal"];
            this.direccionEscalera = _data["direccionEscalera"];
            this.direccionPlanta = _data["direccionPlanta"];
            this.direccionPuerta = _data["direccionPuerta"];
            this.direccionCodigoPostal = _data["direccionCodigoPostal"];
            this.direccionEntidaddePoblacion = _data["direccionEntidaddePoblacion"];
            this.direccionMunicipio = _data["direccionMunicipio"];
            this.direccionProvincia = _data["direccionProvincia"];
            this.direccionPais = _data["direccionPais"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCitaDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCitaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pacienteId"] = this.pacienteId;
        data["fechaHora"] = this.fechaHora ? this.fechaHora.toISOString() : <any>undefined;
        data["consulta"] = this.consulta;
        data["servicio_Especialidad"] = this.servicio_Especialidad;
        data["centro"] = this.centro;
        data["direccionTipo"] = this.direccionTipo;
        data["direccionNombre"] = this.direccionNombre;
        data["direccionNumero"] = this.direccionNumero;
        data["direccionLetra"] = this.direccionLetra;
        data["direccionKmenlavia"] = this.direccionKmenlavia;
        data["direccionBloque"] = this.direccionBloque;
        data["direccionPortal"] = this.direccionPortal;
        data["direccionEscalera"] = this.direccionEscalera;
        data["direccionPlanta"] = this.direccionPlanta;
        data["direccionPuerta"] = this.direccionPuerta;
        data["direccionCodigoPostal"] = this.direccionCodigoPostal;
        data["direccionEntidaddePoblacion"] = this.direccionEntidaddePoblacion;
        data["direccionMunicipio"] = this.direccionMunicipio;
        data["direccionProvincia"] = this.direccionProvincia;
        data["direccionPais"] = this.direccionPais;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateCitaDto {
        const json = this.toJSON();
        let result = new CreateCitaDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCitaDto {
    pacienteId: number;
    fechaHora: moment.Moment;
    consulta: string | undefined;
    servicio_Especialidad: string | undefined;
    centro: string | undefined;
    direccionTipo: string | undefined;
    direccionNombre: string | undefined;
    direccionNumero: number;
    direccionLetra: string | undefined;
    direccionKmenlavia: number;
    direccionBloque: string | undefined;
    direccionPortal: string | undefined;
    direccionEscalera: string | undefined;
    direccionPlanta: number;
    direccionPuerta: string;
    direccionCodigoPostal: string | undefined;
    direccionEntidaddePoblacion: string | undefined;
    direccionMunicipio: string | undefined;
    direccionProvincia: string | undefined;
    direccionPais: string | undefined;
    id: number;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string | undefined;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string | undefined;
}

export class ControlTemperaturaDto implements IControlTemperaturaDto {
    temperatura: number;
    fecha: moment.Moment;
    pacienteId: number;

    constructor(data?: IControlTemperaturaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.temperatura = _data["temperatura"];
            this.fecha = _data["fecha"] ? moment(_data["fecha"].toString()) : <any>undefined;
            this.pacienteId = _data["pacienteId"];
        }
    }

    static fromJS(data: any): ControlTemperaturaDto {
        data = typeof data === 'object' ? data : {};
        let result = new ControlTemperaturaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["temperatura"] = this.temperatura;
        data["fecha"] = this.fecha ? this.fecha.toISOString() : <any>undefined;
        data["pacienteId"] = this.pacienteId;
        return data; 
    }

    clone(): ControlTemperaturaDto {
        const json = this.toJSON();
        let result = new ControlTemperaturaDto();
        result.init(json);
        return result;
    }
}

export interface IControlTemperaturaDto {
    temperatura: number;
    fecha: moment.Moment;
    pacienteId: number;
}

export class ControlTemperaturaDtoListResultDto implements IControlTemperaturaDtoListResultDto {
    items: ControlTemperaturaDto[] | undefined;

    constructor(data?: IControlTemperaturaDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ControlTemperaturaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ControlTemperaturaDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ControlTemperaturaDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ControlTemperaturaDtoListResultDto {
        const json = this.toJSON();
        let result = new ControlTemperaturaDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IControlTemperaturaDtoListResultDto {
    items: ControlTemperaturaDto[] | undefined;
}

export class MedicoDto implements IMedicoDto {
    datosPersonalesId: number | undefined;
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    especialidad: string | undefined;
    totalPacientes: number;
    totalCitasHoy: number;
    agenda: CitaDto[] | undefined;
    id: number;

    constructor(data?: IMedicoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datosPersonalesId = _data["datosPersonalesId"];
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.datosPersonalesName = _data["datosPersonalesName"];
            this.datosPersonalesSurname = _data["datosPersonalesSurname"];
            this.datosPersonalesEmailAddress = _data["datosPersonalesEmailAddress"];
            this.datosPersonalesTelefono = _data["datosPersonalesTelefono"];
            this.especialidad = _data["especialidad"];
            this.totalPacientes = _data["totalPacientes"];
            this.totalCitasHoy = _data["totalCitasHoy"];
            if (Array.isArray(_data["agenda"])) {
                this.agenda = [] as any;
                for (let item of _data["agenda"])
                    this.agenda.push(CitaDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MedicoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datosPersonalesId"] = this.datosPersonalesId;
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["datosPersonalesName"] = this.datosPersonalesName;
        data["datosPersonalesSurname"] = this.datosPersonalesSurname;
        data["datosPersonalesEmailAddress"] = this.datosPersonalesEmailAddress;
        data["datosPersonalesTelefono"] = this.datosPersonalesTelefono;
        data["especialidad"] = this.especialidad;
        data["totalPacientes"] = this.totalPacientes;
        data["totalCitasHoy"] = this.totalCitasHoy;
        if (Array.isArray(this.agenda)) {
            data["agenda"] = [];
            for (let item of this.agenda)
                data["agenda"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): MedicoDto {
        const json = this.toJSON();
        let result = new MedicoDto();
        result.init(json);
        return result;
    }
}

export interface IMedicoDto {
    datosPersonalesId: number | undefined;
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    especialidad: string | undefined;
    totalPacientes: number;
    totalCitasHoy: number;
    agenda: CitaDto[] | undefined;
    id: number;
}

export class EditMedicoDto implements IEditMedicoDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    especialidad: string | undefined;
    id: number;

    constructor(data?: IEditMedicoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.datosPersonalesName = _data["datosPersonalesName"];
            this.datosPersonalesSurname = _data["datosPersonalesSurname"];
            this.datosPersonalesEmailAddress = _data["datosPersonalesEmailAddress"];
            this.datosPersonalesTelefono = _data["datosPersonalesTelefono"];
            this.especialidad = _data["especialidad"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditMedicoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditMedicoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["datosPersonalesName"] = this.datosPersonalesName;
        data["datosPersonalesSurname"] = this.datosPersonalesSurname;
        data["datosPersonalesEmailAddress"] = this.datosPersonalesEmailAddress;
        data["datosPersonalesTelefono"] = this.datosPersonalesTelefono;
        data["especialidad"] = this.especialidad;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditMedicoDto {
        const json = this.toJSON();
        let result = new EditMedicoDto();
        result.init(json);
        return result;
    }
}

export interface IEditMedicoDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    especialidad: string | undefined;
    id: number;
}

export class PacienteCompletoDto implements IPacienteCompletoDto {
    datosPersonalesId: number;
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    fechaNacimiento: moment.Moment;
    numSeguridadSocial: number;
    dondeViveId: number;
    dondeViveTipo: string | undefined;
    dondeViveNombre: string | undefined;
    dondeViveNumero: number;
    dondeViveLetra: string | undefined;
    dondeViveKm_en_la_via: number;
    dondeViveBloque: string | undefined;
    dondeVivePortal: string | undefined;
    dondeViveEscalera: string | undefined;
    dondeVivePlanta: number;
    dondeVivePuerta: string;
    dondeViveCodigo_Postal: string | undefined;
    dondeViveEntidad_de_Poblacion: string | undefined;
    dondeViveMunicipio: string | undefined;
    dondeViveProvincia: string | undefined;
    dondeVivePais: string | undefined;
    termometroId: number;
    termometroFabricante: string | undefined;
    temperatura_Media: number;
    miMedicoCabeceraId: number;
    miMedicoCabeceraDatosPersonalesId: number | undefined;
    miMedicoCabeceraDatosPersonalesUserName: string | undefined;
    miMedicoCabeceraDatosPersonalesName: string | undefined;
    miMedicoCabeceraDatosPersonalesSurname: string | undefined;
    miMedicoCabeceraDatosPersonalesEmailAddress: string | undefined;
    miMedicoCabeceraDatosPersonalesTelefono: string | undefined;
    miMedicoCabeceraEspecialidad: string | undefined;
    total_responsables: number;
    id: number;

    constructor(data?: IPacienteCompletoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datosPersonalesId = _data["datosPersonalesId"];
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.datosPersonalesName = _data["datosPersonalesName"];
            this.datosPersonalesSurname = _data["datosPersonalesSurname"];
            this.datosPersonalesEmailAddress = _data["datosPersonalesEmailAddress"];
            this.datosPersonalesTelefono = _data["datosPersonalesTelefono"];
            this.fechaNacimiento = _data["fechaNacimiento"] ? moment(_data["fechaNacimiento"].toString()) : <any>undefined;
            this.numSeguridadSocial = _data["numSeguridadSocial"];
            this.dondeViveId = _data["dondeViveId"];
            this.dondeViveTipo = _data["dondeViveTipo"];
            this.dondeViveNombre = _data["dondeViveNombre"];
            this.dondeViveNumero = _data["dondeViveNumero"];
            this.dondeViveLetra = _data["dondeViveLetra"];
            this.dondeViveKm_en_la_via = _data["dondeViveKm_en_la_via"];
            this.dondeViveBloque = _data["dondeViveBloque"];
            this.dondeVivePortal = _data["dondeVivePortal"];
            this.dondeViveEscalera = _data["dondeViveEscalera"];
            this.dondeVivePlanta = _data["dondeVivePlanta"];
            this.dondeVivePuerta = _data["dondeVivePuerta"];
            this.dondeViveCodigo_Postal = _data["dondeViveCodigo_Postal"];
            this.dondeViveEntidad_de_Poblacion = _data["dondeViveEntidad_de_Poblacion"];
            this.dondeViveMunicipio = _data["dondeViveMunicipio"];
            this.dondeViveProvincia = _data["dondeViveProvincia"];
            this.dondeVivePais = _data["dondeVivePais"];
            this.termometroId = _data["termometroId"];
            this.termometroFabricante = _data["termometroFabricante"];
            this.temperatura_Media = _data["temperatura_Media"];
            this.miMedicoCabeceraId = _data["miMedicoCabeceraId"];
            this.miMedicoCabeceraDatosPersonalesId = _data["miMedicoCabeceraDatosPersonalesId"];
            this.miMedicoCabeceraDatosPersonalesUserName = _data["miMedicoCabeceraDatosPersonalesUserName"];
            this.miMedicoCabeceraDatosPersonalesName = _data["miMedicoCabeceraDatosPersonalesName"];
            this.miMedicoCabeceraDatosPersonalesSurname = _data["miMedicoCabeceraDatosPersonalesSurname"];
            this.miMedicoCabeceraDatosPersonalesEmailAddress = _data["miMedicoCabeceraDatosPersonalesEmailAddress"];
            this.miMedicoCabeceraDatosPersonalesTelefono = _data["miMedicoCabeceraDatosPersonalesTelefono"];
            this.miMedicoCabeceraEspecialidad = _data["miMedicoCabeceraEspecialidad"];
            this.total_responsables = _data["total_responsables"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PacienteCompletoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PacienteCompletoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datosPersonalesId"] = this.datosPersonalesId;
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["datosPersonalesName"] = this.datosPersonalesName;
        data["datosPersonalesSurname"] = this.datosPersonalesSurname;
        data["datosPersonalesEmailAddress"] = this.datosPersonalesEmailAddress;
        data["datosPersonalesTelefono"] = this.datosPersonalesTelefono;
        data["fechaNacimiento"] = this.fechaNacimiento ? this.fechaNacimiento.toISOString() : <any>undefined;
        data["numSeguridadSocial"] = this.numSeguridadSocial;
        data["dondeViveId"] = this.dondeViveId;
        data["dondeViveTipo"] = this.dondeViveTipo;
        data["dondeViveNombre"] = this.dondeViveNombre;
        data["dondeViveNumero"] = this.dondeViveNumero;
        data["dondeViveLetra"] = this.dondeViveLetra;
        data["dondeViveKm_en_la_via"] = this.dondeViveKm_en_la_via;
        data["dondeViveBloque"] = this.dondeViveBloque;
        data["dondeVivePortal"] = this.dondeVivePortal;
        data["dondeViveEscalera"] = this.dondeViveEscalera;
        data["dondeVivePlanta"] = this.dondeVivePlanta;
        data["dondeVivePuerta"] = this.dondeVivePuerta;
        data["dondeViveCodigo_Postal"] = this.dondeViveCodigo_Postal;
        data["dondeViveEntidad_de_Poblacion"] = this.dondeViveEntidad_de_Poblacion;
        data["dondeViveMunicipio"] = this.dondeViveMunicipio;
        data["dondeViveProvincia"] = this.dondeViveProvincia;
        data["dondeVivePais"] = this.dondeVivePais;
        data["termometroId"] = this.termometroId;
        data["termometroFabricante"] = this.termometroFabricante;
        data["temperatura_Media"] = this.temperatura_Media;
        data["miMedicoCabeceraId"] = this.miMedicoCabeceraId;
        data["miMedicoCabeceraDatosPersonalesId"] = this.miMedicoCabeceraDatosPersonalesId;
        data["miMedicoCabeceraDatosPersonalesUserName"] = this.miMedicoCabeceraDatosPersonalesUserName;
        data["miMedicoCabeceraDatosPersonalesName"] = this.miMedicoCabeceraDatosPersonalesName;
        data["miMedicoCabeceraDatosPersonalesSurname"] = this.miMedicoCabeceraDatosPersonalesSurname;
        data["miMedicoCabeceraDatosPersonalesEmailAddress"] = this.miMedicoCabeceraDatosPersonalesEmailAddress;
        data["miMedicoCabeceraDatosPersonalesTelefono"] = this.miMedicoCabeceraDatosPersonalesTelefono;
        data["miMedicoCabeceraEspecialidad"] = this.miMedicoCabeceraEspecialidad;
        data["total_responsables"] = this.total_responsables;
        data["id"] = this.id;
        return data; 
    }

    clone(): PacienteCompletoDto {
        const json = this.toJSON();
        let result = new PacienteCompletoDto();
        result.init(json);
        return result;
    }
}

export interface IPacienteCompletoDto {
    datosPersonalesId: number;
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    fechaNacimiento: moment.Moment;
    numSeguridadSocial: number;
    dondeViveId: number;
    dondeViveTipo: string | undefined;
    dondeViveNombre: string | undefined;
    dondeViveNumero: number;
    dondeViveLetra: string | undefined;
    dondeViveKm_en_la_via: number;
    dondeViveBloque: string | undefined;
    dondeVivePortal: string | undefined;
    dondeViveEscalera: string | undefined;
    dondeVivePlanta: number;
    dondeVivePuerta: string;
    dondeViveCodigo_Postal: string | undefined;
    dondeViveEntidad_de_Poblacion: string | undefined;
    dondeViveMunicipio: string | undefined;
    dondeViveProvincia: string | undefined;
    dondeVivePais: string | undefined;
    termometroId: number;
    termometroFabricante: string | undefined;
    temperatura_Media: number;
    miMedicoCabeceraId: number;
    miMedicoCabeceraDatosPersonalesId: number | undefined;
    miMedicoCabeceraDatosPersonalesUserName: string | undefined;
    miMedicoCabeceraDatosPersonalesName: string | undefined;
    miMedicoCabeceraDatosPersonalesSurname: string | undefined;
    miMedicoCabeceraDatosPersonalesEmailAddress: string | undefined;
    miMedicoCabeceraDatosPersonalesTelefono: string | undefined;
    miMedicoCabeceraEspecialidad: string | undefined;
    total_responsables: number;
    id: number;
}

export class ResponsableDto implements IResponsableDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    id: number;

    constructor(data?: IResponsableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.datosPersonalesName = _data["datosPersonalesName"];
            this.datosPersonalesSurname = _data["datosPersonalesSurname"];
            this.datosPersonalesEmailAddress = _data["datosPersonalesEmailAddress"];
            this.datosPersonalesTelefono = _data["datosPersonalesTelefono"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ResponsableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponsableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["datosPersonalesName"] = this.datosPersonalesName;
        data["datosPersonalesSurname"] = this.datosPersonalesSurname;
        data["datosPersonalesEmailAddress"] = this.datosPersonalesEmailAddress;
        data["datosPersonalesTelefono"] = this.datosPersonalesTelefono;
        data["id"] = this.id;
        return data; 
    }

    clone(): ResponsableDto {
        const json = this.toJSON();
        let result = new ResponsableDto();
        result.init(json);
        return result;
    }
}

export interface IResponsableDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    id: number;
}

export class PacienteMiResponsableDto implements IPacienteMiResponsableDto {
    responsable: ResponsableDto;

    constructor(data?: IPacienteMiResponsableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responsable = _data["responsable"] ? ResponsableDto.fromJS(_data["responsable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PacienteMiResponsableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PacienteMiResponsableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responsable"] = this.responsable ? this.responsable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PacienteMiResponsableDto {
        const json = this.toJSON();
        let result = new PacienteMiResponsableDto();
        result.init(json);
        return result;
    }
}

export interface IPacienteMiResponsableDto {
    responsable: ResponsableDto;
}

export class MisResponsables implements IMisResponsables {
    numSeguridadSocial: number;
    pacienteDatosPersonalesFullName: string | undefined;
    responsables: PacienteMiResponsableDto[] | undefined;
    id: number;

    constructor(data?: IMisResponsables) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numSeguridadSocial = _data["numSeguridadSocial"];
            this.pacienteDatosPersonalesFullName = _data["pacienteDatosPersonalesFullName"];
            if (Array.isArray(_data["responsables"])) {
                this.responsables = [] as any;
                for (let item of _data["responsables"])
                    this.responsables.push(PacienteMiResponsableDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MisResponsables {
        data = typeof data === 'object' ? data : {};
        let result = new MisResponsables();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numSeguridadSocial"] = this.numSeguridadSocial;
        data["pacienteDatosPersonalesFullName"] = this.pacienteDatosPersonalesFullName;
        if (Array.isArray(this.responsables)) {
            data["responsables"] = [];
            for (let item of this.responsables)
                data["responsables"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): MisResponsables {
        const json = this.toJSON();
        let result = new MisResponsables();
        result.init(json);
        return result;
    }
}

export interface IMisResponsables {
    numSeguridadSocial: number;
    pacienteDatosPersonalesFullName: string | undefined;
    responsables: PacienteMiResponsableDto[] | undefined;
    id: number;
}

export class EnfermedadDto implements IEnfermedadDto {
    nombre: string | undefined;
    sintomas: string | undefined;
    causas: string | undefined;
    id: number;

    constructor(data?: IEnfermedadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.sintomas = _data["sintomas"];
            this.causas = _data["causas"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EnfermedadDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnfermedadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["sintomas"] = this.sintomas;
        data["causas"] = this.causas;
        data["id"] = this.id;
        return data; 
    }

    clone(): EnfermedadDto {
        const json = this.toJSON();
        let result = new EnfermedadDto();
        result.init(json);
        return result;
    }
}

export interface IEnfermedadDto {
    nombre: string | undefined;
    sintomas: string | undefined;
    causas: string | undefined;
    id: number;
}

export class EnfermedadPacienteDto implements IEnfermedadPacienteDto {
    enfermedad: EnfermedadDto;
    id: number;

    constructor(data?: IEnfermedadPacienteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enfermedad = _data["enfermedad"] ? EnfermedadDto.fromJS(_data["enfermedad"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EnfermedadPacienteDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnfermedadPacienteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enfermedad"] = this.enfermedad ? this.enfermedad.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): EnfermedadPacienteDto {
        const json = this.toJSON();
        let result = new EnfermedadPacienteDto();
        result.init(json);
        return result;
    }
}

export interface IEnfermedadPacienteDto {
    enfermedad: EnfermedadDto;
    id: number;
}

export class MisEnfermedades implements IMisEnfermedades {
    pacienteNumSeguridadSocial: number;
    pacienteDatosPersonalesFullName: string | undefined;
    misEnfermedades: EnfermedadPacienteDto[] | undefined;
    id: number;

    constructor(data?: IMisEnfermedades) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pacienteNumSeguridadSocial = _data["pacienteNumSeguridadSocial"];
            this.pacienteDatosPersonalesFullName = _data["pacienteDatosPersonalesFullName"];
            if (Array.isArray(_data["misEnfermedades"])) {
                this.misEnfermedades = [] as any;
                for (let item of _data["misEnfermedades"])
                    this.misEnfermedades.push(EnfermedadPacienteDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MisEnfermedades {
        data = typeof data === 'object' ? data : {};
        let result = new MisEnfermedades();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pacienteNumSeguridadSocial"] = this.pacienteNumSeguridadSocial;
        data["pacienteDatosPersonalesFullName"] = this.pacienteDatosPersonalesFullName;
        if (Array.isArray(this.misEnfermedades)) {
            data["misEnfermedades"] = [];
            for (let item of this.misEnfermedades)
                data["misEnfermedades"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): MisEnfermedades {
        const json = this.toJSON();
        let result = new MisEnfermedades();
        result.init(json);
        return result;
    }
}

export interface IMisEnfermedades {
    pacienteNumSeguridadSocial: number;
    pacienteDatosPersonalesFullName: string | undefined;
    misEnfermedades: EnfermedadPacienteDto[] | undefined;
    id: number;
}

export class MedicamentoDto implements IMedicamentoDto {
    nombre: string | undefined;
    tipo: string | undefined;
    gramaje: string | undefined;
    funcionalidad: string | undefined;
    componenteBase: string | undefined;
    id: number;

    constructor(data?: IMedicamentoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.tipo = _data["tipo"];
            this.gramaje = _data["gramaje"];
            this.funcionalidad = _data["funcionalidad"];
            this.componenteBase = _data["componenteBase"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MedicamentoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicamentoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["tipo"] = this.tipo;
        data["gramaje"] = this.gramaje;
        data["funcionalidad"] = this.funcionalidad;
        data["componenteBase"] = this.componenteBase;
        data["id"] = this.id;
        return data; 
    }

    clone(): MedicamentoDto {
        const json = this.toJSON();
        let result = new MedicamentoDto();
        result.init(json);
        return result;
    }
}

export interface IMedicamentoDto {
    nombre: string | undefined;
    tipo: string | undefined;
    gramaje: string | undefined;
    funcionalidad: string | undefined;
    componenteBase: string | undefined;
    id: number;
}

export class PrescripcionDto implements IPrescripcionDto {
    medicamento: MedicamentoDto;
    dosis: string | undefined;
    fecha_Inicio: moment.Moment;
    fecha_Final: moment.Moment;
    isManana: boolean;
    isTarde: boolean;
    isNoche: boolean;
    pacienteId: number;
    id: number;

    constructor(data?: IPrescripcionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.medicamento = new MedicamentoDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.medicamento = _data["medicamento"] ? MedicamentoDto.fromJS(_data["medicamento"]) : new MedicamentoDto();
            this.dosis = _data["dosis"];
            this.fecha_Inicio = _data["fecha_Inicio"] ? moment(_data["fecha_Inicio"].toString()) : <any>undefined;
            this.fecha_Final = _data["fecha_Final"] ? moment(_data["fecha_Final"].toString()) : <any>undefined;
            this.isManana = _data["isManana"];
            this.isTarde = _data["isTarde"];
            this.isNoche = _data["isNoche"];
            this.pacienteId = _data["pacienteId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PrescripcionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrescripcionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["medicamento"] = this.medicamento ? this.medicamento.toJSON() : <any>undefined;
        data["dosis"] = this.dosis;
        data["fecha_Inicio"] = this.fecha_Inicio ? this.fecha_Inicio.toISOString() : <any>undefined;
        data["fecha_Final"] = this.fecha_Final ? this.fecha_Final.toISOString() : <any>undefined;
        data["isManana"] = this.isManana;
        data["isTarde"] = this.isTarde;
        data["isNoche"] = this.isNoche;
        data["pacienteId"] = this.pacienteId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PrescripcionDto {
        const json = this.toJSON();
        let result = new PrescripcionDto();
        result.init(json);
        return result;
    }
}

export interface IPrescripcionDto {
    medicamento: MedicamentoDto;
    dosis: string | undefined;
    fecha_Inicio: moment.Moment;
    fecha_Final: moment.Moment;
    isManana: boolean;
    isTarde: boolean;
    isNoche: boolean;
    pacienteId: number;
    id: number;
}

export class MisPrescripciones implements IMisPrescripciones {
    misPrescripciones: PrescripcionDto[] | undefined;
    id: number;

    constructor(data?: IMisPrescripciones) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["misPrescripciones"])) {
                this.misPrescripciones = [] as any;
                for (let item of _data["misPrescripciones"])
                    this.misPrescripciones.push(PrescripcionDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MisPrescripciones {
        data = typeof data === 'object' ? data : {};
        let result = new MisPrescripciones();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.misPrescripciones)) {
            data["misPrescripciones"] = [];
            for (let item of this.misPrescripciones)
                data["misPrescripciones"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): MisPrescripciones {
        const json = this.toJSON();
        let result = new MisPrescripciones();
        result.init(json);
        return result;
    }
}

export interface IMisPrescripciones {
    misPrescripciones: PrescripcionDto[] | undefined;
    id: number;
}

export class RecordatorioDto implements IRecordatorioDto {
    fechaHora: moment.Moment;
    texto: string | undefined;
    id: number;

    constructor(data?: IRecordatorioDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fechaHora = _data["fechaHora"] ? moment(_data["fechaHora"].toString()) : <any>undefined;
            this.texto = _data["texto"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RecordatorioDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecordatorioDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fechaHora"] = this.fechaHora ? this.fechaHora.toISOString() : <any>undefined;
        data["texto"] = this.texto;
        data["id"] = this.id;
        return data; 
    }

    clone(): RecordatorioDto {
        const json = this.toJSON();
        let result = new RecordatorioDto();
        result.init(json);
        return result;
    }
}

export interface IRecordatorioDto {
    fechaHora: moment.Moment;
    texto: string | undefined;
    id: number;
}

export class MisRecordatorios implements IMisRecordatorios {
    recordatorios: RecordatorioDto[] | undefined;
    id: number;

    constructor(data?: IMisRecordatorios) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["recordatorios"])) {
                this.recordatorios = [] as any;
                for (let item of _data["recordatorios"])
                    this.recordatorios.push(RecordatorioDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MisRecordatorios {
        data = typeof data === 'object' ? data : {};
        let result = new MisRecordatorios();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.recordatorios)) {
            data["recordatorios"] = [];
            for (let item of this.recordatorios)
                data["recordatorios"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): MisRecordatorios {
        const json = this.toJSON();
        let result = new MisRecordatorios();
        result.init(json);
        return result;
    }
}

export interface IMisRecordatorios {
    recordatorios: RecordatorioDto[] | undefined;
    id: number;
}

export class DatosResponsableDto implements IDatosResponsableDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    totalPacientes: number;
    id: number;

    constructor(data?: IDatosResponsableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.datosPersonalesName = _data["datosPersonalesName"];
            this.datosPersonalesSurname = _data["datosPersonalesSurname"];
            this.datosPersonalesEmailAddress = _data["datosPersonalesEmailAddress"];
            this.datosPersonalesTelefono = _data["datosPersonalesTelefono"];
            this.totalPacientes = _data["totalPacientes"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DatosResponsableDto {
        data = typeof data === 'object' ? data : {};
        let result = new DatosResponsableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["datosPersonalesName"] = this.datosPersonalesName;
        data["datosPersonalesSurname"] = this.datosPersonalesSurname;
        data["datosPersonalesEmailAddress"] = this.datosPersonalesEmailAddress;
        data["datosPersonalesTelefono"] = this.datosPersonalesTelefono;
        data["totalPacientes"] = this.totalPacientes;
        data["id"] = this.id;
        return data; 
    }

    clone(): DatosResponsableDto {
        const json = this.toJSON();
        let result = new DatosResponsableDto();
        result.init(json);
        return result;
    }
}

export interface IDatosResponsableDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    totalPacientes: number;
    id: number;
}

export class EditResponsableDto implements IEditResponsableDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    id: number;

    constructor(data?: IEditResponsableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.datosPersonalesName = _data["datosPersonalesName"];
            this.datosPersonalesSurname = _data["datosPersonalesSurname"];
            this.datosPersonalesEmailAddress = _data["datosPersonalesEmailAddress"];
            this.datosPersonalesTelefono = _data["datosPersonalesTelefono"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditResponsableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditResponsableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["datosPersonalesName"] = this.datosPersonalesName;
        data["datosPersonalesSurname"] = this.datosPersonalesSurname;
        data["datosPersonalesEmailAddress"] = this.datosPersonalesEmailAddress;
        data["datosPersonalesTelefono"] = this.datosPersonalesTelefono;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditResponsableDto {
        const json = this.toJSON();
        let result = new EditResponsableDto();
        result.init(json);
        return result;
    }
}

export interface IEditResponsableDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    id: number;
}

export class EnfermedadDtoListResultDto implements IEnfermedadDtoListResultDto {
    items: EnfermedadDto[] | undefined;

    constructor(data?: IEnfermedadDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(EnfermedadDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnfermedadDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnfermedadDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EnfermedadDtoListResultDto {
        const json = this.toJSON();
        let result = new EnfermedadDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IEnfermedadDtoListResultDto {
    items: EnfermedadDto[] | undefined;
}

export class EnfermedadPacienteDtoListResultDto implements IEnfermedadPacienteDtoListResultDto {
    items: EnfermedadPacienteDto[] | undefined;

    constructor(data?: IEnfermedadPacienteDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(EnfermedadPacienteDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnfermedadPacienteDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnfermedadPacienteDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EnfermedadPacienteDtoListResultDto {
        const json = this.toJSON();
        let result = new EnfermedadPacienteDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IEnfermedadPacienteDtoListResultDto {
    items: EnfermedadPacienteDto[] | undefined;
}

export class PacienteDto implements IPacienteDto {
    numSeguridadSocial: number;
    datosPersonalesId: number;
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    fechaNacimiento: moment.Moment;
    id: number;

    constructor(data?: IPacienteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numSeguridadSocial = _data["numSeguridadSocial"];
            this.datosPersonalesId = _data["datosPersonalesId"];
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.datosPersonalesName = _data["datosPersonalesName"];
            this.datosPersonalesSurname = _data["datosPersonalesSurname"];
            this.datosPersonalesEmailAddress = _data["datosPersonalesEmailAddress"];
            this.datosPersonalesTelefono = _data["datosPersonalesTelefono"];
            this.fechaNacimiento = _data["fechaNacimiento"] ? moment(_data["fechaNacimiento"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PacienteDto {
        data = typeof data === 'object' ? data : {};
        let result = new PacienteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numSeguridadSocial"] = this.numSeguridadSocial;
        data["datosPersonalesId"] = this.datosPersonalesId;
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["datosPersonalesName"] = this.datosPersonalesName;
        data["datosPersonalesSurname"] = this.datosPersonalesSurname;
        data["datosPersonalesEmailAddress"] = this.datosPersonalesEmailAddress;
        data["datosPersonalesTelefono"] = this.datosPersonalesTelefono;
        data["fechaNacimiento"] = this.fechaNacimiento ? this.fechaNacimiento.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): PacienteDto {
        const json = this.toJSON();
        let result = new PacienteDto();
        result.init(json);
        return result;
    }
}

export interface IPacienteDto {
    numSeguridadSocial: number;
    datosPersonalesId: number;
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    fechaNacimiento: moment.Moment;
    id: number;
}

export class PacienteEnfermedadDto implements IPacienteEnfermedadDto {
    paciente: PacienteDto;
    id: number;

    constructor(data?: IPacienteEnfermedadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paciente = _data["paciente"] ? PacienteDto.fromJS(_data["paciente"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PacienteEnfermedadDto {
        data = typeof data === 'object' ? data : {};
        let result = new PacienteEnfermedadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paciente"] = this.paciente ? this.paciente.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): PacienteEnfermedadDto {
        const json = this.toJSON();
        let result = new PacienteEnfermedadDto();
        result.init(json);
        return result;
    }
}

export interface IPacienteEnfermedadDto {
    paciente: PacienteDto;
    id: number;
}

export class MedicamentoDtoListResultDto implements IMedicamentoDtoListResultDto {
    items: MedicamentoDto[] | undefined;

    constructor(data?: IMedicamentoDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MedicamentoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MedicamentoDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicamentoDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MedicamentoDtoListResultDto {
        const json = this.toJSON();
        let result = new MedicamentoDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IMedicamentoDtoListResultDto {
    items: MedicamentoDto[] | undefined;
}

export class MedicoDtoListResultDto implements IMedicoDtoListResultDto {
    items: MedicoDto[] | undefined;

    constructor(data?: IMedicoDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MedicoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MedicoDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicoDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MedicoDtoListResultDto {
        const json = this.toJSON();
        let result = new MedicoDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IMedicoDtoListResultDto {
    items: MedicoDto[] | undefined;
}

export class UserNameMedicoDto implements IUserNameMedicoDto {
    datosPersonalesUserName: string | undefined;
    id: number;

    constructor(data?: IUserNameMedicoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserNameMedicoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserNameMedicoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserNameMedicoDto {
        const json = this.toJSON();
        let result = new UserNameMedicoDto();
        result.init(json);
        return result;
    }
}

export interface IUserNameMedicoDto {
    datosPersonalesUserName: string | undefined;
    id: number;
}

export class UserNameMedicoDtoListResultDto implements IUserNameMedicoDtoListResultDto {
    items: UserNameMedicoDto[] | undefined;

    constructor(data?: IUserNameMedicoDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserNameMedicoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserNameMedicoDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserNameMedicoDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserNameMedicoDtoListResultDto {
        const json = this.toJSON();
        let result = new UserNameMedicoDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserNameMedicoDtoListResultDto {
    items: UserNameMedicoDto[] | undefined;
}

export class MedicoDtoPagedResultDto implements IMedicoDtoPagedResultDto {
    totalCount: number;
    items: MedicoDto[] | undefined;

    constructor(data?: IMedicoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MedicoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MedicoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MedicoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MedicoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMedicoDtoPagedResultDto {
    totalCount: number;
    items: MedicoDto[] | undefined;
}

export class CreateMedicoDto implements ICreateMedicoDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    datosPersonalesIsActive: boolean;
    datosPersonalesPassword: string | undefined;
    datosPersonalesRoleNames: string[] | undefined;
    especialidad: string | undefined;
    id: number;

    constructor(data?: ICreateMedicoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.datosPersonalesName = _data["datosPersonalesName"];
            this.datosPersonalesSurname = _data["datosPersonalesSurname"];
            this.datosPersonalesEmailAddress = _data["datosPersonalesEmailAddress"];
            this.datosPersonalesTelefono = _data["datosPersonalesTelefono"];
            this.datosPersonalesIsActive = _data["datosPersonalesIsActive"];
            this.datosPersonalesPassword = _data["datosPersonalesPassword"];
            if (Array.isArray(_data["datosPersonalesRoleNames"])) {
                this.datosPersonalesRoleNames = [] as any;
                for (let item of _data["datosPersonalesRoleNames"])
                    this.datosPersonalesRoleNames.push(item);
            }
            this.especialidad = _data["especialidad"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateMedicoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMedicoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["datosPersonalesName"] = this.datosPersonalesName;
        data["datosPersonalesSurname"] = this.datosPersonalesSurname;
        data["datosPersonalesEmailAddress"] = this.datosPersonalesEmailAddress;
        data["datosPersonalesTelefono"] = this.datosPersonalesTelefono;
        data["datosPersonalesIsActive"] = this.datosPersonalesIsActive;
        data["datosPersonalesPassword"] = this.datosPersonalesPassword;
        if (Array.isArray(this.datosPersonalesRoleNames)) {
            data["datosPersonalesRoleNames"] = [];
            for (let item of this.datosPersonalesRoleNames)
                data["datosPersonalesRoleNames"].push(item);
        }
        data["especialidad"] = this.especialidad;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateMedicoDto {
        const json = this.toJSON();
        let result = new CreateMedicoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateMedicoDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    datosPersonalesIsActive: boolean;
    datosPersonalesPassword: string | undefined;
    datosPersonalesRoleNames: string[] | undefined;
    especialidad: string | undefined;
    id: number;
}

export class CreateMensajeDto implements ICreateMensajeDto {
    personaDestinoUserName: string | undefined;
    texto: string | undefined;
    fecha: moment.Moment;

    constructor(data?: ICreateMensajeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personaDestinoUserName = _data["personaDestinoUserName"];
            this.texto = _data["texto"];
            this.fecha = _data["fecha"] ? moment(_data["fecha"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateMensajeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMensajeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personaDestinoUserName"] = this.personaDestinoUserName;
        data["texto"] = this.texto;
        data["fecha"] = this.fecha ? this.fecha.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CreateMensajeDto {
        const json = this.toJSON();
        let result = new CreateMensajeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateMensajeDto {
    personaDestinoUserName: string | undefined;
    texto: string | undefined;
    fecha: moment.Moment;
}

export class MensajeDto implements IMensajeDto {
    personaOrigenUserName: string | undefined;
    personaDestinoUserName: string | undefined;
    texto: string | undefined;
    fecha: moment.Moment;
    isLeido: boolean;
    isRecibido: boolean;
    id: number;

    constructor(data?: IMensajeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personaOrigenUserName = _data["personaOrigenUserName"];
            this.personaDestinoUserName = _data["personaDestinoUserName"];
            this.texto = _data["texto"];
            this.fecha = _data["fecha"] ? moment(_data["fecha"].toString()) : <any>undefined;
            this.isLeido = _data["isLeido"];
            this.isRecibido = _data["isRecibido"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MensajeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MensajeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personaOrigenUserName"] = this.personaOrigenUserName;
        data["personaDestinoUserName"] = this.personaDestinoUserName;
        data["texto"] = this.texto;
        data["fecha"] = this.fecha ? this.fecha.toISOString() : <any>undefined;
        data["isLeido"] = this.isLeido;
        data["isRecibido"] = this.isRecibido;
        data["id"] = this.id;
        return data; 
    }

    clone(): MensajeDto {
        const json = this.toJSON();
        let result = new MensajeDto();
        result.init(json);
        return result;
    }
}

export interface IMensajeDto {
    personaOrigenUserName: string | undefined;
    personaDestinoUserName: string | undefined;
    texto: string | undefined;
    fecha: moment.Moment;
    isLeido: boolean;
    isRecibido: boolean;
    id: number;
}

export class MensajeSimple implements IMensajeSimple {
    personaId: number;
    personaUserName: string | undefined;
    fechaHora: moment.Moment;
    texto: string | undefined;

    constructor(data?: IMensajeSimple) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personaId = _data["personaId"];
            this.personaUserName = _data["personaUserName"];
            this.fechaHora = _data["fechaHora"] ? moment(_data["fechaHora"].toString()) : <any>undefined;
            this.texto = _data["texto"];
        }
    }

    static fromJS(data: any): MensajeSimple {
        data = typeof data === 'object' ? data : {};
        let result = new MensajeSimple();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personaId"] = this.personaId;
        data["personaUserName"] = this.personaUserName;
        data["fechaHora"] = this.fechaHora ? this.fechaHora.toISOString() : <any>undefined;
        data["texto"] = this.texto;
        return data; 
    }

    clone(): MensajeSimple {
        const json = this.toJSON();
        let result = new MensajeSimple();
        result.init(json);
        return result;
    }
}

export interface IMensajeSimple {
    personaId: number;
    personaUserName: string | undefined;
    fechaHora: moment.Moment;
    texto: string | undefined;
}

export class MensajeSimpleListResultDto implements IMensajeSimpleListResultDto {
    items: MensajeSimple[] | undefined;

    constructor(data?: IMensajeSimpleListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MensajeSimple.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MensajeSimpleListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MensajeSimpleListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MensajeSimpleListResultDto {
        const json = this.toJSON();
        let result = new MensajeSimpleListResultDto();
        result.init(json);
        return result;
    }
}

export interface IMensajeSimpleListResultDto {
    items: MensajeSimple[] | undefined;
}

export class MensajeDtoListResultDto implements IMensajeDtoListResultDto {
    items: MensajeDto[] | undefined;

    constructor(data?: IMensajeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MensajeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MensajeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MensajeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MensajeDtoListResultDto {
        const json = this.toJSON();
        let result = new MensajeDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IMensajeDtoListResultDto {
    items: MensajeDto[] | undefined;
}

export class MensajeDtoPagedResultDto implements IMensajeDtoPagedResultDto {
    totalCount: number;
    items: MensajeDto[] | undefined;

    constructor(data?: IMensajeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MensajeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MensajeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MensajeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MensajeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MensajeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMensajeDtoPagedResultDto {
    totalCount: number;
    items: MensajeDto[] | undefined;
}

export class PacienteMiResponsableDtoListResultDto implements IPacienteMiResponsableDtoListResultDto {
    items: PacienteMiResponsableDto[] | undefined;

    constructor(data?: IPacienteMiResponsableDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PacienteMiResponsableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PacienteMiResponsableDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PacienteMiResponsableDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PacienteMiResponsableDtoListResultDto {
        const json = this.toJSON();
        let result = new PacienteMiResponsableDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPacienteMiResponsableDtoListResultDto {
    items: PacienteMiResponsableDto[] | undefined;
}

export class PacienteDtoListResultDto implements IPacienteDtoListResultDto {
    items: PacienteDto[] | undefined;

    constructor(data?: IPacienteDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PacienteDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PacienteDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PacienteDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PacienteDtoListResultDto {
        const json = this.toJSON();
        let result = new PacienteDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPacienteDtoListResultDto {
    items: PacienteDto[] | undefined;
}

export class MisEnfermedadesListResultDto implements IMisEnfermedadesListResultDto {
    items: MisEnfermedades[] | undefined;

    constructor(data?: IMisEnfermedadesListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MisEnfermedades.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MisEnfermedadesListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MisEnfermedadesListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MisEnfermedadesListResultDto {
        const json = this.toJSON();
        let result = new MisEnfermedadesListResultDto();
        result.init(json);
        return result;
    }
}

export interface IMisEnfermedadesListResultDto {
    items: MisEnfermedades[] | undefined;
}

export class MiEvolucionTemperatura implements IMiEvolucionTemperatura {
    control_de_Temperatura: ControlTemperaturaDto[] | undefined;
    id: number;

    constructor(data?: IMiEvolucionTemperatura) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["control_de_Temperatura"])) {
                this.control_de_Temperatura = [] as any;
                for (let item of _data["control_de_Temperatura"])
                    this.control_de_Temperatura.push(ControlTemperaturaDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MiEvolucionTemperatura {
        data = typeof data === 'object' ? data : {};
        let result = new MiEvolucionTemperatura();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.control_de_Temperatura)) {
            data["control_de_Temperatura"] = [];
            for (let item of this.control_de_Temperatura)
                data["control_de_Temperatura"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): MiEvolucionTemperatura {
        const json = this.toJSON();
        let result = new MiEvolucionTemperatura();
        result.init(json);
        return result;
    }
}

export interface IMiEvolucionTemperatura {
    control_de_Temperatura: ControlTemperaturaDto[] | undefined;
    id: number;
}

export class CreatePacienteDto implements ICreatePacienteDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    datosPersonalesIsActive: boolean;
    datosPersonalesPassword: string | undefined;
    datosPersonalesRoleNames: string[] | undefined;
    fechaNacimiento: moment.Moment;
    numSeguridadSocial: number;
    dondeViveId: number;
    dondeViveTipo: string | undefined;
    dondeViveNombre: string | undefined;
    dondeViveNumero: number;
    dondeViveLetra: string | undefined;
    dondeViveKm_en_la_via: number;
    dondeViveBloque: string | undefined;
    dondeVivePortal: string | undefined;
    dondeViveEscalera: string | undefined;
    dondeVivePlanta: number;
    dondeVivePuerta: string;
    dondeViveCodigoPostal: string | undefined;
    dondeViveEntidad_de_Poblacion: string | undefined;
    dondeViveMunicipio: string | undefined;
    dondeViveProvincia: string | undefined;
    dondeVivePais: string | undefined;
    id: number;

    constructor(data?: ICreatePacienteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.datosPersonalesName = _data["datosPersonalesName"];
            this.datosPersonalesSurname = _data["datosPersonalesSurname"];
            this.datosPersonalesEmailAddress = _data["datosPersonalesEmailAddress"];
            this.datosPersonalesTelefono = _data["datosPersonalesTelefono"];
            this.datosPersonalesIsActive = _data["datosPersonalesIsActive"];
            this.datosPersonalesPassword = _data["datosPersonalesPassword"];
            if (Array.isArray(_data["datosPersonalesRoleNames"])) {
                this.datosPersonalesRoleNames = [] as any;
                for (let item of _data["datosPersonalesRoleNames"])
                    this.datosPersonalesRoleNames.push(item);
            }
            this.fechaNacimiento = _data["fechaNacimiento"] ? moment(_data["fechaNacimiento"].toString()) : <any>undefined;
            this.numSeguridadSocial = _data["numSeguridadSocial"];
            this.dondeViveId = _data["dondeViveId"];
            this.dondeViveTipo = _data["dondeViveTipo"];
            this.dondeViveNombre = _data["dondeViveNombre"];
            this.dondeViveNumero = _data["dondeViveNumero"];
            this.dondeViveLetra = _data["dondeViveLetra"];
            this.dondeViveKm_en_la_via = _data["dondeViveKm_en_la_via"];
            this.dondeViveBloque = _data["dondeViveBloque"];
            this.dondeVivePortal = _data["dondeVivePortal"];
            this.dondeViveEscalera = _data["dondeViveEscalera"];
            this.dondeVivePlanta = _data["dondeVivePlanta"];
            this.dondeVivePuerta = _data["dondeVivePuerta"];
            this.dondeViveCodigoPostal = _data["dondeViveCodigoPostal"];
            this.dondeViveEntidad_de_Poblacion = _data["dondeViveEntidad_de_Poblacion"];
            this.dondeViveMunicipio = _data["dondeViveMunicipio"];
            this.dondeViveProvincia = _data["dondeViveProvincia"];
            this.dondeVivePais = _data["dondeVivePais"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreatePacienteDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePacienteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["datosPersonalesName"] = this.datosPersonalesName;
        data["datosPersonalesSurname"] = this.datosPersonalesSurname;
        data["datosPersonalesEmailAddress"] = this.datosPersonalesEmailAddress;
        data["datosPersonalesTelefono"] = this.datosPersonalesTelefono;
        data["datosPersonalesIsActive"] = this.datosPersonalesIsActive;
        data["datosPersonalesPassword"] = this.datosPersonalesPassword;
        if (Array.isArray(this.datosPersonalesRoleNames)) {
            data["datosPersonalesRoleNames"] = [];
            for (let item of this.datosPersonalesRoleNames)
                data["datosPersonalesRoleNames"].push(item);
        }
        data["fechaNacimiento"] = this.fechaNacimiento ? this.fechaNacimiento.toISOString() : <any>undefined;
        data["numSeguridadSocial"] = this.numSeguridadSocial;
        data["dondeViveId"] = this.dondeViveId;
        data["dondeViveTipo"] = this.dondeViveTipo;
        data["dondeViveNombre"] = this.dondeViveNombre;
        data["dondeViveNumero"] = this.dondeViveNumero;
        data["dondeViveLetra"] = this.dondeViveLetra;
        data["dondeViveKm_en_la_via"] = this.dondeViveKm_en_la_via;
        data["dondeViveBloque"] = this.dondeViveBloque;
        data["dondeVivePortal"] = this.dondeVivePortal;
        data["dondeViveEscalera"] = this.dondeViveEscalera;
        data["dondeVivePlanta"] = this.dondeVivePlanta;
        data["dondeVivePuerta"] = this.dondeVivePuerta;
        data["dondeViveCodigoPostal"] = this.dondeViveCodigoPostal;
        data["dondeViveEntidad_de_Poblacion"] = this.dondeViveEntidad_de_Poblacion;
        data["dondeViveMunicipio"] = this.dondeViveMunicipio;
        data["dondeViveProvincia"] = this.dondeViveProvincia;
        data["dondeVivePais"] = this.dondeVivePais;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreatePacienteDto {
        const json = this.toJSON();
        let result = new CreatePacienteDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePacienteDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    datosPersonalesIsActive: boolean;
    datosPersonalesPassword: string | undefined;
    datosPersonalesRoleNames: string[] | undefined;
    fechaNacimiento: moment.Moment;
    numSeguridadSocial: number;
    dondeViveId: number;
    dondeViveTipo: string | undefined;
    dondeViveNombre: string | undefined;
    dondeViveNumero: number;
    dondeViveLetra: string | undefined;
    dondeViveKm_en_la_via: number;
    dondeViveBloque: string | undefined;
    dondeVivePortal: string | undefined;
    dondeViveEscalera: string | undefined;
    dondeVivePlanta: number;
    dondeVivePuerta: string;
    dondeViveCodigoPostal: string | undefined;
    dondeViveEntidad_de_Poblacion: string | undefined;
    dondeViveMunicipio: string | undefined;
    dondeViveProvincia: string | undefined;
    dondeVivePais: string | undefined;
    id: number;
}

export class EditPacienteDto implements IEditPacienteDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    fechaNacimiento: moment.Moment;
    numSeguridadSocial: number;
    dondeViveId: number;
    dondeViveTipo: string | undefined;
    dondeViveNombre: string | undefined;
    dondeViveNumero: number;
    dondeViveLetra: string | undefined;
    dondeViveKm_en_la_via: number;
    dondeViveBloque: string | undefined;
    dondeVivePortal: string | undefined;
    dondeViveEscalera: string | undefined;
    dondeVivePlanta: number;
    dondeVivePuerta: string;
    dondeViveCodigoPostal: string | undefined;
    dondeViveEntidad_de_Poblacion: string | undefined;
    dondeViveMunicipio: string | undefined;
    dondeViveProvincia: string | undefined;
    dondeVivePais: string | undefined;
    medicoCabeceraUserName: string | undefined;
    id: number;

    constructor(data?: IEditPacienteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.datosPersonalesName = _data["datosPersonalesName"];
            this.datosPersonalesSurname = _data["datosPersonalesSurname"];
            this.datosPersonalesEmailAddress = _data["datosPersonalesEmailAddress"];
            this.datosPersonalesTelefono = _data["datosPersonalesTelefono"];
            this.fechaNacimiento = _data["fechaNacimiento"] ? moment(_data["fechaNacimiento"].toString()) : <any>undefined;
            this.numSeguridadSocial = _data["numSeguridadSocial"];
            this.dondeViveId = _data["dondeViveId"];
            this.dondeViveTipo = _data["dondeViveTipo"];
            this.dondeViveNombre = _data["dondeViveNombre"];
            this.dondeViveNumero = _data["dondeViveNumero"];
            this.dondeViveLetra = _data["dondeViveLetra"];
            this.dondeViveKm_en_la_via = _data["dondeViveKm_en_la_via"];
            this.dondeViveBloque = _data["dondeViveBloque"];
            this.dondeVivePortal = _data["dondeVivePortal"];
            this.dondeViveEscalera = _data["dondeViveEscalera"];
            this.dondeVivePlanta = _data["dondeVivePlanta"];
            this.dondeVivePuerta = _data["dondeVivePuerta"];
            this.dondeViveCodigoPostal = _data["dondeViveCodigoPostal"];
            this.dondeViveEntidad_de_Poblacion = _data["dondeViveEntidad_de_Poblacion"];
            this.dondeViveMunicipio = _data["dondeViveMunicipio"];
            this.dondeViveProvincia = _data["dondeViveProvincia"];
            this.dondeVivePais = _data["dondeVivePais"];
            this.medicoCabeceraUserName = _data["medicoCabeceraUserName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditPacienteDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditPacienteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["datosPersonalesName"] = this.datosPersonalesName;
        data["datosPersonalesSurname"] = this.datosPersonalesSurname;
        data["datosPersonalesEmailAddress"] = this.datosPersonalesEmailAddress;
        data["datosPersonalesTelefono"] = this.datosPersonalesTelefono;
        data["fechaNacimiento"] = this.fechaNacimiento ? this.fechaNacimiento.toISOString() : <any>undefined;
        data["numSeguridadSocial"] = this.numSeguridadSocial;
        data["dondeViveId"] = this.dondeViveId;
        data["dondeViveTipo"] = this.dondeViveTipo;
        data["dondeViveNombre"] = this.dondeViveNombre;
        data["dondeViveNumero"] = this.dondeViveNumero;
        data["dondeViveLetra"] = this.dondeViveLetra;
        data["dondeViveKm_en_la_via"] = this.dondeViveKm_en_la_via;
        data["dondeViveBloque"] = this.dondeViveBloque;
        data["dondeVivePortal"] = this.dondeVivePortal;
        data["dondeViveEscalera"] = this.dondeViveEscalera;
        data["dondeVivePlanta"] = this.dondeVivePlanta;
        data["dondeVivePuerta"] = this.dondeVivePuerta;
        data["dondeViveCodigoPostal"] = this.dondeViveCodigoPostal;
        data["dondeViveEntidad_de_Poblacion"] = this.dondeViveEntidad_de_Poblacion;
        data["dondeViveMunicipio"] = this.dondeViveMunicipio;
        data["dondeViveProvincia"] = this.dondeViveProvincia;
        data["dondeVivePais"] = this.dondeVivePais;
        data["medicoCabeceraUserName"] = this.medicoCabeceraUserName;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditPacienteDto {
        const json = this.toJSON();
        let result = new EditPacienteDto();
        result.init(json);
        return result;
    }
}

export interface IEditPacienteDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    fechaNacimiento: moment.Moment;
    numSeguridadSocial: number;
    dondeViveId: number;
    dondeViveTipo: string | undefined;
    dondeViveNombre: string | undefined;
    dondeViveNumero: number;
    dondeViveLetra: string | undefined;
    dondeViveKm_en_la_via: number;
    dondeViveBloque: string | undefined;
    dondeVivePortal: string | undefined;
    dondeViveEscalera: string | undefined;
    dondeVivePlanta: number;
    dondeVivePuerta: string;
    dondeViveCodigoPostal: string | undefined;
    dondeViveEntidad_de_Poblacion: string | undefined;
    dondeViveMunicipio: string | undefined;
    dondeViveProvincia: string | undefined;
    dondeVivePais: string | undefined;
    medicoCabeceraUserName: string | undefined;
    id: number;
}

export class UserNameMedicosCabecera implements IUserNameMedicosCabecera {
    userName: string | undefined;

    constructor(data?: IUserNameMedicosCabecera) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UserNameMedicosCabecera {
        data = typeof data === 'object' ? data : {};
        let result = new UserNameMedicosCabecera();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        return data; 
    }

    clone(): UserNameMedicosCabecera {
        const json = this.toJSON();
        let result = new UserNameMedicosCabecera();
        result.init(json);
        return result;
    }
}

export interface IUserNameMedicosCabecera {
    userName: string | undefined;
}

export class UserNameMedicosCabeceraListResultDto implements IUserNameMedicosCabeceraListResultDto {
    items: UserNameMedicosCabecera[] | undefined;

    constructor(data?: IUserNameMedicosCabeceraListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserNameMedicosCabecera.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserNameMedicosCabeceraListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserNameMedicosCabeceraListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserNameMedicosCabeceraListResultDto {
        const json = this.toJSON();
        let result = new UserNameMedicosCabeceraListResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserNameMedicosCabeceraListResultDto {
    items: UserNameMedicosCabecera[] | undefined;
}

export class CreatePrescripcionDto implements ICreatePrescripcionDto {
    medicamentoId: number;
    dosis: string | undefined;
    fecha_Inicio: moment.Moment;
    fecha_Final: moment.Moment;
    como_Tomar: string | undefined;
    id: number;

    constructor(data?: ICreatePrescripcionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.medicamentoId = _data["medicamentoId"];
            this.dosis = _data["dosis"];
            this.fecha_Inicio = _data["fecha_Inicio"] ? moment(_data["fecha_Inicio"].toString()) : <any>undefined;
            this.fecha_Final = _data["fecha_Final"] ? moment(_data["fecha_Final"].toString()) : <any>undefined;
            this.como_Tomar = _data["como_Tomar"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreatePrescripcionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePrescripcionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["medicamentoId"] = this.medicamentoId;
        data["dosis"] = this.dosis;
        data["fecha_Inicio"] = this.fecha_Inicio ? this.fecha_Inicio.toISOString() : <any>undefined;
        data["fecha_Final"] = this.fecha_Final ? this.fecha_Final.toISOString() : <any>undefined;
        data["como_Tomar"] = this.como_Tomar;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreatePrescripcionDto {
        const json = this.toJSON();
        let result = new CreatePrescripcionDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePrescripcionDto {
    medicamentoId: number;
    dosis: string | undefined;
    fecha_Inicio: moment.Moment;
    fecha_Final: moment.Moment;
    como_Tomar: string | undefined;
    id: number;
}

export class RecordatorioDtoListResultDto implements IRecordatorioDtoListResultDto {
    items: RecordatorioDto[] | undefined;

    constructor(data?: IRecordatorioDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RecordatorioDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecordatorioDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecordatorioDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RecordatorioDtoListResultDto {
        const json = this.toJSON();
        let result = new RecordatorioDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRecordatorioDtoListResultDto {
    items: RecordatorioDto[] | undefined;
}

export class CreateResponsableDto implements ICreateResponsableDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    datosPersonalesIsActive: boolean;
    datosPersonalesPassword: string | undefined;
    id: number;

    constructor(data?: ICreateResponsableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datosPersonalesUserName = _data["datosPersonalesUserName"];
            this.datosPersonalesName = _data["datosPersonalesName"];
            this.datosPersonalesSurname = _data["datosPersonalesSurname"];
            this.datosPersonalesEmailAddress = _data["datosPersonalesEmailAddress"];
            this.datosPersonalesTelefono = _data["datosPersonalesTelefono"];
            this.datosPersonalesIsActive = _data["datosPersonalesIsActive"];
            this.datosPersonalesPassword = _data["datosPersonalesPassword"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateResponsableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateResponsableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datosPersonalesUserName"] = this.datosPersonalesUserName;
        data["datosPersonalesName"] = this.datosPersonalesName;
        data["datosPersonalesSurname"] = this.datosPersonalesSurname;
        data["datosPersonalesEmailAddress"] = this.datosPersonalesEmailAddress;
        data["datosPersonalesTelefono"] = this.datosPersonalesTelefono;
        data["datosPersonalesIsActive"] = this.datosPersonalesIsActive;
        data["datosPersonalesPassword"] = this.datosPersonalesPassword;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateResponsableDto {
        const json = this.toJSON();
        let result = new CreateResponsableDto();
        result.init(json);
        return result;
    }
}

export interface ICreateResponsableDto {
    datosPersonalesUserName: string | undefined;
    datosPersonalesName: string | undefined;
    datosPersonalesSurname: string | undefined;
    datosPersonalesEmailAddress: string | undefined;
    datosPersonalesTelefono: string | undefined;
    datosPersonalesIsActive: boolean;
    datosPersonalesPassword: string | undefined;
    id: number;
}

export class ResponsableDtoListResultDto implements IResponsableDtoListResultDto {
    items: ResponsableDto[] | undefined;

    constructor(data?: IResponsableDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ResponsableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponsableDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponsableDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ResponsableDtoListResultDto {
        const json = this.toJSON();
        let result = new ResponsableDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IResponsableDtoListResultDto {
    items: ResponsableDto[] | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isStatic: boolean;
    id: number;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isStatic: boolean;
    id: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        this.features[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    roles: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.roles = _data["roles"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["roles"] = this.roles;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    roles: string | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string | undefined;
    name: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string | undefined;
    name: string | undefined;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string | undefined;
    providerKey: string | undefined;
    providerAccessCode: string | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string | undefined;
    providerKey: string | undefined;
    providerAccessCode: string | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    telefono: string | undefined;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.telefono = _data["telefono"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["telefono"] = this.telefono;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    telefono: string | undefined;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string | undefined;
}

export class UserDto implements IUserDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string | undefined;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string | undefined;
    newPassword: string | undefined;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string | undefined;
    newPassword: string | undefined;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string | undefined;
    userId: number;
    newPassword: string | undefined;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string | undefined;
    userId: number;
    newPassword: string | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}